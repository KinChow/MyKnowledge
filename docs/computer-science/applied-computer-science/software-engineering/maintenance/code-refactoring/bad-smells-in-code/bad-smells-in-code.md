# 代码坏味道

任何代码的腐化，代码坏味道只是表面现象，对需求易变性的估计不足、功能地重复式、片段式植入等等才是腐化的原因。

* 冗余和重复
* 局部膨胀
* 耦合不良
* 结构不良



## 神秘命名

### 现象

* 函数、模块、变量和类的命名不准确



### 问题

* 函数、模块、变量和类的命名难以表达其功能和用法



### 解决办法

* 改变函数声明（给函数改名）
* 变量改名
* 字段改名



## 重复代码

### 现象

* 如果你在一个以上的地点看到相同的代码结构，那么可以肯定：设法将它们合而为一，程序会变得更好。
* 最单纯的重复代码就是“同一个类的两个函数含有相同的表达式”。
* 还有重复代码只是相似而不是完全相同。



### 问题

* 重复代码是万恶之源，会衍生出其他绝大多数的坏味道
* 最常见的是一旦变化，到处修改，漏改一处就是bug



### 解决办法

* 提炼函数
* 移动语句
* 函数上移



## 过长函数

### 现象

* 函数很长。



### 问题

* 函数难以理解和维护。



### 解决办法

* 提炼函数
* 以查询取代临时变量
* 引入参数对象
* 保持对象完整
* 以命令取代函数
* 分解条件表达式
* 以多态取代条件表达式
* 拆分循环



## 过长参数列表

### 现象

* 函数有太多参数。



### 问题

* 太多的参数难以理解。
* 需要更多数据时，不得不修改参数，太多参数会造成前后不一致，不易使用。



### 解决办法

* 以查询取代参数
* 保持对象完整
* 引入参数对象
* 移除标记参数
* 函数组合成类



## 全局数据

### 现象

* 全局数据在任意地方都可以修改，难以维护。



### 问题

* 从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改。一次又一次，全局数据造成了那些诡异的bug，而问题的根源却在遥远的别处，想要找到出错的代码难于登天。



### 解决办法

* 封装变量



## 可变数据

### 现象

* 在一处更新了数据，软件中另一处期望者完全不同的数据，导致功能失效。



### 问题

* 对数据的修改经常导致出乎意料的结果和难以发现的bug。



### 解决办法

* 封装变量
* 拆分变量移动语句
* 移动语句
* 提炼函数
* 将查询函数和修改函数分离
* 移除设值函数
* 以查询取代派生变量
* 函数组合成类
* 函数组合成变换
* 将引用对象改为值对象



## 发散式变化

### 现象

* 某个模块经常因为不同的原因在不同的方向上发生变化。



### 问题

* 模块（类、函数）的职责过多，理解困难。
* 多个不同方向变化冗余相互影响，维护难度大。



### 解决办法

* 拆分阶段
* 搬移函数
* 提炼函数
* 提炼类



## 霰弹式修改

### 现象

* 如果遇到某种变化，都需要在许多不同的类中修改。



### 问题

* 如果修改的代码分散在不同文件，不但难以找到这些代码，还有容易遗漏某些代码的修改。
* 修改多个模块造成多处功能影响，增加了配套验证等工作。



### 解决办法

* 搬移函数
* 搬移字段
* 函数组合成类
* 函数组合成变换
* 拆分阶段
* 内联函数
* 内联类



## 依恋情结

### 现象

* 一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流。



### 问题

* 难以理解和维护。
* 违反模块化原则：力求将代码分出区域，最大化区域内部的交互、最小化跨区域的交互。



### 解决办法

* 搬移函数
* 提炼函数



## 数据泥团

### 现象

* 两个类中相同的字段、许多函数签名中相同的参数。



### 问题

* 这些总是绑在一起出现的数据应该拥有属于它们自己的对象。



### 解决办法

* 提炼类
* 引入参数对象
* 保持对象完整



## 基本类型偏执

### 现象

* 大量使用基本类型，即整数、浮点数和字符串等。而不愿意创建对自己问题域有用的类。



### 问题

* 难以表示其对象的真实含义。比如用整型表示钱，就忽略了钱的单位。



### 解决办法

* 以对象取代基本类型
* 以子类取代类型码
* 以多态取代条件表达式
* 提炼类
* 引入参数对象



## 重复的switch

### 现象

* switch语句是根据类型码进行的多分支选择语句，写出短小的switch语句很难，即便是只有两种条件的switch语句也要比想要的单个代码块或函数大得多。写出只做一件事的switch语句也很难，switch天生要做多件事。



### 问题

* 每增加新的类型码，都要增加case分支，导致分支越来越多，函数不再短小简洁，违反了开闭原则（OCP）。
* 单个case分支中做了多件事，同样会导致函数冗长，包含多个抽象层级，违反了单一职责原则（SRP）。
* 相同的switch语句散布在多个函数中，新增类型码时，必须找到所有switch语句并修改他们，霰弹式修改容易遗漏。



### 解决办法

* 以多态取代条件表达式



## 循环语句

### 现象

* 使用循环语句。



### 问题

* 循环语句有点过时。



### 解决办法

* 以管道取代循环



## 冗赘的元素

### 现象

* 程序元素（如类和函数）能给代码增加结构，从而支持变化、促进复用或者哪怕只是提供更好的名字也好，但有时我们真的不需要这层额外的结构。



### 问题

* 随着重构的进行，一些最初设计的全面的代码只有简单的作用。



### 解决办法

* 内联函数
* 内联类
* 折叠继承关系



## 夸夸其谈通用性

### 现象

* 企图以各式各样的钩子和特殊情况来处理一些非必要的事情。
* 过度关注未来可能的变化，增加不必要的东西。



### 问题

* 过度的设计导致代码不易理解和错误不易定位，也许会降低代码的执行效率
* 当程序中过量使用设计模式，导致在代码的阅读过程中很难找到主要的逻辑走向
* 放置过量的钩子或特殊情况来处理一些非必要的事情，可能在代码的编写调试过程中加深跟踪bug的难度



### 解决办法

* 折叠继承体系
* 内联函数
* 内联类
* 改变函数声明
* 移除死代码



## 临时字段

### 现象

* 类内部某个字段仅为某种特定情况而设。
* 只在该对象某一段生命周期内生效。



### 问题

* 代码不易理解，通常认为对象在所有时候都需要它的所有变量。
* 在变量未被使用的情况下猜测当初其设置目的。
* 在“我以为”的情况下误用该变量，导致某些场景异常。



### 解决办法

* 提炼类
* 搬移函数
* 引入特例



## 过长的消息链

### 现象

* 如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。在实际代码中你看到的可能是一长串取值函数或一长串临时变量。



### 问题

* 一旦对象间的关系发生任何变化，客户端就不得不做出相应修改。



### 解决办法

* 隐藏委托关系
* 提炼函数
* 搬移函数



## 中间人

### 现象

* 某个类的接口有一半的函数都委托给其他类。过度运用委托。



### 问题

* 没有和真正负责的对象打交道。



### 解决办法

* 移除中间人
* 内联函数
* 以委托取代超类
* 以委托取代子类



## 内幕交易

### 现象

* 一定的数据交换不可避免，但我们必须尽量减少这种情况，并把这种交换都放到明面上来。



### 问题

* 减少模块间的耦合。



### 解决办法

* 搬移函数
* 搬移数据
* 隐藏委托关系
* 以委托取代子类
* 以委托取代超类



## 过大的类

### 现象

* 单个类做太多事情，内部出现太多字段。



### 问题

* 容易造成重复代码。



### 解决办法

* 提炼类
* 提炼超类
* 以子类取代类型码



## 异曲同工的类

### 现象

* 两个类有不同的函数，但是实现相同的功能。



### 问题

* 容易造成代码重复
* 代码可读性变差
* 功能变化后，难以维护



### 解决办法

* 改变函数声明
* 搬移函数
* 提炼超类



## 纯数据类

### 现象

* 纯数据类：拥有一些属性，以及用于访问（读写）这些属性的函数，除此之外一无长物。



### 问题

* 纯数据类只是一种不会说话的数据容器，它们几乎一 定被其他类过分细琐地操控着，意味着纯数据类的行为放错到别的地方。



### 解决办法

* 封装记录
* 移除设值函数
* 搬移函数
* 提炼函数
* 拆分阶段



## 被拒绝的遗赠

### 现象

* 子类不想继承超类的函数和数据。



### 问题

* 设计错误。



### 解决办法

* 函数下移
* 字段下移
* 以委托取代子类
* 以委托取代超类



## 注释

### 现象

* 一段代码有着长长的注释，这些注释之所以存在是因为代码很糟糕。



### 问题

* 多余的注释破坏代码的可读性
* 误导性注释让维护人员陷入困难



### 解决办法

* 提炼函数
* 改变函数声明
* 引入断言

