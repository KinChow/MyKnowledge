# C++对象生命周期及RAII

## C++的资源分配：从编译、链接到执行

### C++从源文件到obj的编译

* `.text` 可执行的代码段
*  `.init` 初始化段，在main()之前执行，可用来完成全局变量的初始化，如调用所有全局对象的构造函数。
* `.fini` 程序结束段，在程序终止前执行，可用来完成对全局变量的析构函数的调用。
*  `.data` 包含程序的只读数据区，如常量字符串的存储位置，由编译期间决定
* `.bss` 包括不需要在目标代码中分配空间，但是需要程序加载时初始化的数据段



### C++从obj到可执行文件的链接

* `text`段是程序代码段，由编译器在编译连接时自动计算的，当你在链接定位文件中将该符号放置在代码段后，那么该符号表示的值就是代码段大小，编译连接时，该符号所代表的值会自动代入到源程序中。
* `data`包含静态初始化的数据，所以有初值的全局变量和static变量在data区。段的起始位置也是由连接定位文件所确定，大小在编译连接时自动分配，它和你的程序大小没有关系，但和程序使用到的全局变量，常量数量相关。
* `bss`是英文Block Started by Symbol的简称，通常是指用来存放程序中未初始化的全局变量的一块内存区域，在程序载入时由内核清0。BSS段属于静态内存分配。



### 可执行文件运行时的内存印射

进程用户空间

* 栈stack
    * stack段存储参数变量和局部变量，函数参数，函数调用信息。
    *  stack由系統进行申请和释放，属于静态内存分配。
    *   stack的特意是先进后出，可用于保存/恢复调用现场。
    *  “先进后出”，这种结构保护之前的现场，如一个函数被调用后，产生的临时变量都会存到栈区的顶部，当函数完成后，会自动从顶部将刚使用的数据销毁。另外栈区的地址是从高地址向下增长的。
* 堆heap
    * heap段是程序运行过程中动态分配的内存段，由用户申请和释放（例如malloc/free, new/delete）。
    * heap使用时地址向上增长。
    * 程序中不释放的heap只有在程序结束时，才由OS回收。所以持续运行中，如果不及时释放内存段，会导致内存泄漏，也就是堆栈区爆炸。
* bss segment
* data segment
* text segment



### const和static关键字

* const
    * const用来修饰变量只读，其修饰有时间段的意义
        * 函数`int function(const int *input_param)`声明，只表示在该函数调用期间，入参不会被修改
    * const是编译器在语言上检查保证不被修改，实际上使用const_cast转化，或者C语言风格的强转，依然能改变其只读属性，对const常量进行赋值
    * 对全局常量进行const_cast后进行赋值，是未定义行为
* static
    * static用来修饰作用域。static变量/常量是全局共享的，生命周期是整个程序运行期间。所有的static变量/常量都在全局数据区（bss/data）
        * 静态全局变量/常量只对本文件可见
        * 静态局部变量/常量只对作用域（函数内）可见
        * 静态成员变量/常量只对class内部可见
    * static还能作为声明静态成员函数的关键字
        * 可以不实例化对象，直接调用class中的函数



## C++对象的内存分配方式

### C++ class/struct的内部存储排布

#### 为什么要字节对齐？

CPU读取一次能读取到的内存大小跟数据总线的位数有关；如果为32位（x86架构）CPU一次可以读取4字节，那么在存储这个int变量的时候编译器会将让这个变量的起始地址能够被4整除，那么这样就不会导致这个int类型的变量明明没有超过数据总线位数而需要CPU两次才能将其读取出来，这就是字节对齐。



#### 字节对齐方式由什么决定？

实际的对齐方式由编译器和最终的硬件决定



规则

* 规则一：结构体中元素按照定义顺序依次置于内存中，但并不是紧密排列。从结构体首地址开始依次将元素放入内存时，元素会被放置在其自身对齐大小的整数倍地址上。这里说的地址是元素在结构体中的偏移量，结构体首地址偏移量为0。
*   规则二：如果结构体大小不是所有元素中最大对齐大小的整数倍，则结构体对齐到最大元素对齐大小的整数倍，填充空间放置到结构体末尾。
*  规则三：结构体中的基本数据类型的对齐大小为其自身的大小



#### 组合和继承

* 组合和继承
    *  组合按照顺序依次往下排布
    *  继承从基类开始往子类进行排布
* 组合和继承区别：
    *  继承相当于把所有元素打平在一起，按照前述规则进行计算
    *  组合的情况下，内部的结构体需先按照前述规则进行计算，再计算当前总size的计算



#### 虚函数

*  如果一个类中有虚函数，会多出一个指针的空间
*  注：多继承情况下会有多个vptr



## C++栈存储的分配与释放

### C++是基于栈的语言



## C++堆存储（动态存储）的分配与释放

### 动态分配/释放内存的全局函数

* `void *operator new(size t sz);`
* `void operator delete(void* p);`
* `void *operator new[](size_t sz);`
* `void operator delete[](void* p);`



### 操作符new/delete的过程

#### 操作符new的过程

1. 调用new函数分配空间（此时需要指定分配空间大小，所以需要指定size_t，分配内存时没有类型信息，所以返回void*）
2. 调用构造函数，构造出对象，返回构造出的对象



#### 操作符delete的过程

1. 调用对象的析构函数
2. 调用delete函数，回收自由空间



### 数组的new和delete

#### 对new的数组进行delete会怎么样？

1. delete只删除了p指针的第一个元素
2. 必须使用delete[]删除数组才能正确调用所有的析构函数



#### new和delete可以重载，但必须成对定义

* 自定义操作符的时候，new和delete要配对定义，new[]和delete[]要配对定义。
* 自定义new/delete操作符的对外表现行为要与被替换的对应new/delete操作符一致。



#### 异常处理与智能指针

为什么要使用异常？

1.   容错。C++引入异常处理的原因
2.   错误处理与程序逻辑的分离
3.   异常情况的分级处理
4.   简化错误处理（为什么说C语言函数的返回值有着坏名声）



如何优雅的在异常出现时，防止资源（内存）泄漏？
什么是智能指针 （smartPtr）？



### C++类对象的内存管理实例

#### 避免构造不完整的对象

*  构造函数应该有一个契约：构造后的对象是满足不变式（invariant）的、完整的、可用的。由于构造函数没有返回值，无法通过返回错误码的形式报告错误，因此在允许使用异常的情况下，应当使用异常来报告错误。
*  对象构造在堆上时，如果构造函数抛出异常，那么对象的堆内存会被自动释放。但是要注意：如果构造函数分配了其他关联的资源，则需要程序员保证资源可以被全部释放。使用智能指针和RAII有助于保证资源被正确释放。



#### 特殊的成员函数

明确需要实现哪些特殊成员函数

*  三之法则（Rule of three）：若某个类需要用户定义的析构函数、拷贝构造函数或拷贝赋值操作符，则它基本同时需要这三个函数。
    * 如果类对某种资源进行管理，而资源句柄是非类类型的对象（裸指针、文件描述符等），则这些隐式定义的成员函数通常都不正确，其析构函数不做任何事，而拷贝构造函数/拷贝赋值操作符则进行“浅拷贝”。
    * 通过可复制句柄来管理不可复制资源的类，必须将其拷贝赋值和拷贝构造函数声明为私有的并且不提供其定义，或将它们定义为delete的。
*  五之法则（Rule of five）：如果定义了析构函数、拷贝构造函数或拷贝赋值操作符，会阻止移动构造函数和移动赋值操作符的隐式定义，所以任何想要移动语义的类必须声明全部五个特殊成员函数。std::move将对象的状态或者所有权从一个对象转到另一个对象
    * 但是如果不提供移动构造函数和移动赋值操作符通常不会发生错误，但会导致失去优化机会。
*  零之法则（Rule of zero）：如果类不需要专门处理资源的所有权，那么就不应该有自定义的析构函数、拷贝/移动构造函数或拷贝/移动赋值操作符。



#### 禁止在构造函数和析构函数中调用虚函数

* 在构造函数和析构函数中调用当前对象的虚函数，会导致未实现多态的行为。
* 在C++中，一个基类一次只构造一个完整的对象



#### 多态基类中的拷贝构造函数、拷贝赋值操作符、移动构造函数、移动赋值操作符必须为非public函数或者delete函数

* 如果把一个派生类对象直接赋值给基类对象，会发生切片，只拷贝或者移动了基类部分，损害了多态行为。



#### delete操作符、移动构造函数、移动赋值操作符、swap函数应该有noexcept声明（建议）

* 这些操作会被隐式调用，调用时不期望异常抛出



### 继承

通过基类指针释放派生类时，必须将基类中析构函数声明为虚函数

* 只有基类析构函数是虚函数时，才能保证通过多态调用的时候调用到派生类的析构函数。
* 如果没有将基类的析构函数声明为虚函数，当通过基类指针释放派生类时，只会调用基类的析构函数，不会调用派生类的析构函数，导致内存泄漏。



禁止重新定义public继承而来的非虚函数



禁止将指向派生类对象数组的指针赋值给指向基类的指针



### std::move/std::forward与移动拷贝/赋值操作

#### 五法则（Rule of five）

如果定义了析构函数、拷贝构造函数或拷贝赋值操作符，会阻止移动构造函数和移动赋值操作符的隐式定义，所以任何想要移动语义的类必须声明全部五个特殊成员函数。



#### 在移动构造函数和移动赋值操作符中必须将源对象的资源正确重置

移动构造函数和移动赋值操作符将资源的所有权从一个对象移动到另外一个资源。一旦资源被移动，则应将源对象的资源正确重置。这样可以防止源对象在析构函数中释放了被移动的资源。

在被移动的对象中允许保留部分非资源相关数据，但必须保证被移动的对象处于可被正常析构的状态。

因此，当一个对象被move以后，除非该对象处于明确指定的状态，否则不要依赖已move对象的值，否则可能产生非预期行为。



#### 左值与右值

*  `lvalue`是"locator value"，指的是存储在内存中、有明确存储地址（可寻址）的数据
*  `rvalue`是"read value"，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）



在C++或者C语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。

*  能在=左边的就是左值，反之为右值。左值可以作为右值使用： ++a是左值，a++为右值



右值引用（C++11）：&&

*   右值引用可以对右值进行修改，实质变成了一个左值
*   右值引用语法的引入的目的之一是为了实现移动语义



C++11 标准中对右值做了更细致的划分，分別称纯右值（Pure value，简称 pvalue）和将亡值（eXpiring value，简称 xvalue）。其中纯右值就是C++98/03 标准中的右值，而将亡值则指的是和右值引用相关的表达式（比如某函数返回的T&&类型的表达式）。



C++11的引用折叠和右值引用的特殊类型推断
*   规则1（引用折叠规则）：如果间接的创建一个引用的引用，则这些引用就会“折叠”。在所有情况下（除了一个例外），引用折叠成一个普通的左值引用类型。一种特殊情况下，引用会折叠成右值引用，即右值引用的右值引用，T&& &&。即X&&、X&&&、X&&&都折叠成x&。X&&&&折叠为X&&。引用折叠只发生在函数模板中
*   规则2（万能引用）：当将一个左值传递给一个参数是右值引用的函数，且此右值引用指向模板类型参数（T&&）时，编译器推断模板参数类型为实参的左值引用
* 规则3：虽然不能隐式的将一个左值转换为右值引用，但是可以通过static_cast显示地将一个左值转换为一个右值。【C++11中为static_cast新增的转换功能】。



#### std::move

* move函数的参数T&&是一个指向模板类型参数的右值引用【规则2】，通过引用折叠，此参数可以和任何类型的实参匹配，因此move既可以传递一个左值，也可以传递一个右值；
* std::move执行到右值的无条件转换。就其本身而言，它没有move任何东西。两个调用是等价的。



#### std::forward

*  完美转发实现了参数在传递过程中保持其值属性的功能，即若是左值，则传递之后仍然是左值；若是右值，则传递之后仍然是右值。
*  std::forward只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值。



std::move和std::forward只不过就是执行类型转换的两个函数；std::move没有move任何东西，std::forward没有转发任何东西。在运行期，它们没有做任何事情。它们没有产生需要执行的代码。



通过移动拷贝与移动赋值操作，能够节省内存空间，提高性能但是在没有移动拷贝和移动赋值操作的函数情况下，一般也能正常运行！
*   std::move只是使用万能引用及引用折叠的规则将值转化为右值
*   只有定义移动拷贝/赋值的情况下才会走到这里，否则会使用复制构造/赋值操作的函数上去





### C++RAII机制及智能指针

#### RAII

RAll: Resource Acquisition Is Initialization，翻译成中文为“资源获取即初始化”。

*   Modern C++尽量避免使用堆内存，而是通过尽可能在栈上声明对象来实现。
*  如果一个资源太大无法放入栈中时，那它应该被一个对象来拥有。当对象初始化时，它会获取所拥有的资源。对象本身是栈上声明的，对象拥有资源的原则也被称为“资源获取即初始化”(RAII)。
* 当一个拥有资源的栈对象超出其作用域的时候，它的析构函数会自动调用。在这种方式中，C++中的GC和对象的生命周期密切相关，并且是确定性的。资源总是在程序的某个已知点释放，这一点是可以控制的。只有像C++中的确定性析构函数那样，才能同等地处理内存和非内存资源。
一句话总结：通过栈上的对象的生命周期，控制资源的获取与释放



#### 智能指针为了解决什么问题

*  不像Managed Language (JAVA)一样，C++没有自动的GC机制。
*   C++程序需要负责将所有获取到的资源都归还给操作系统。未释放未使用的资源被称为泄漏（Leak）。直到进程退出之前，这部分泄漏的资源对其他程序来说都是不可用的。
*  C风格编程中内存泄漏是十分常见的错误原因之一。
*   智能指针是RAI技术中最重要的组成部分，它使用C++对象包装了裸指针，将声明置于栈上，由系统进行资源管埋，避免了资源泄露



### 变量指针

#### `shared_ptr`

`shared_ptr`是共享指针，意味着创建出来的智能指针可以和其他智能指针共享同一块堆内存。

创建方式：`shared_ptr<T> name = make shared<T>()`；

* use_count()函数可以得到当前指针所指向的内存区域的引用数量。

* reset()函数可以释放当前智能指针对堆内存空间的所有权。



#### `unique_ptr`

`unique_ptr`顾名思义，是独一指针，即不和其他智能指针共享同一块堆内存。

`unigue_ptr`不能赋值给某他`unique_ptr`，只能被移动给其他`unique_ptr`，即同一时间，只能被一个智能指针控制其内存区域的数据。



#### `weak_ptr`

`weak_ptr`是一个比较弱的指针，弱就弱在，它不像`unique_ptr`或者是`shared_ptr`一样，重载了`*`和`->`运算符，即它没有办法修改指定内存区域的值，但是可以访问该内存区。



如果`shared_ptr`和`weak_ptr`指向了同一块堆内存，它不会让`shared_ptr`的引用计数加一，同理`weak_ptr`释放的时候，也不会让`shared_ptr`的引用计数减一，`shared_ptr`和`weak ptr`通常配合使用，基本不会单独使用`weak_ptr`。 解决`shared_ptr`循环引用问题。