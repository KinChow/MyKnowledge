# 类和结构

## 结构、类和联合的对比

| 结构             | 类               | 联合             |
| ---------------- | ---------------- | ---------------- |
| struct           | class            | union            |
| 默认访问是公共的 | 默认访问是私有的 | 默认访问是公共的 |
| 没有使用约束     | 没有使用约束     | 一次只有一个成员 |

在 C++ 中，结构与类相同，只不过结构的成员默认为 `public`。



### class

#### 语法

```c++
[template-spec]
class [ms-decl-spec] [tag [: base-list ]]
{
   member-list
} [declarators];
[ class ] tag declarators;
```

* `template-spec`：可选模板规范。
* `class`：关键字。
* `ms-decl-spec`：可选存储类规范。
* `tag`：为类提供的类型名称。 标记将变成类范围内的保留字。 标记是可选项。 如果省略，则定义匿名类。
* `base-list`：此类将从中派生其成员的类或结构的可选列表。 每个基类或结构名称的前面可具有访问说明符（[public](https://learn.microsoft.com/zh-cn/cpp/cpp/public-cpp?view=msvc-170)、[private](https://learn.microsoft.com/zh-cn/cpp/cpp/private-cpp?view=msvc-170)、[protected](https://learn.microsoft.com/zh-cn/cpp/cpp/protected-cpp?view=msvc-170)）和 [virtual](https://learn.microsoft.com/zh-cn/cpp/cpp/virtual-cpp?view=msvc-170) 关键字。
* `member-list`：类成员列表。
* `declarators`：声明符列表，指定类类型的一个或多个实例的名称。 如果类的所有数据成员是 `public`，则声明符可以包含初始值设定项列表。 与类相比，这在结构（其数据成员默认为 `public`）中更为常见。



### struct

```c++
[template-spec]
struct [ms-decl-spec] [tag [: base-list ]]
{
   member-list
} [declarators];
[struct] tag declarators;
```

* `template-spec`：可选模板规范。 
* `struct`：关键字。
* `ms-decl-spec`：可选存储类规范。
* `tag`：为结构提供的类型名称。 标记将变成结构范围内的保留字。 标记是可选项。 如果省略，则定义匿名结构。
* `base-list`：此结构将从中派生其成员的类或结构的可选列表。 每个基类或结构名称的前面可具有访问说明符（[public](https://learn.microsoft.com/zh-cn/cpp/cpp/public-cpp?view=msvc-170)、[private](https://learn.microsoft.com/zh-cn/cpp/cpp/private-cpp?view=msvc-170)、[protected](https://learn.microsoft.com/zh-cn/cpp/cpp/protected-cpp?view=msvc-170)）和 [virtual](https://learn.microsoft.com/zh-cn/cpp/cpp/virtual-cpp?view=msvc-170) 关键字。
* `member-list`：结构成员列表。这里的唯一区别是，使用 `struct` 代替了 `class`。
* `declarator`：指定结构名称的声明符列表。 声明符列表声明了一个或多个结构类型实例。 如果结构的所有数据成员是 `public`，则声明符可包含初始值设定项列表。 初始值设定项列表在结构中很常见，因为数据成员默认为 `public`。



## 类成员

### 静态成员



### 成员函数

#### 构造函数

##### 默认构造函数

构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？

##### 复制构造函数



##### 移动构造函数



##### 复制赋值运算符



##### 移动赋值运算符



#### 析构函数



#### virtual



#### override



#### final



### 初始化

#### 类成员初始化

方式

成员列表初始化



构造函数的执行顺序



#### 大括号初始化



## 面向对象

### 继承

#### 单个继承

#### 基类

#### 多个基类

#### 虚函数

虚函数是应在派生类中重新定义的成员函数。 当使用指针或对基类的引用来引用派生的类对象时，可以为该对象调用虚函数并执行该函数的派生类版本。

虚函数确保为该对象调用正确的函数，这与用于进行函数调用的表达式无关。

假定基类包含声明为 [virtual](https://learn.microsoft.com/zh-cn/cpp/cpp/virtual-cpp?view=msvc-170) 的函数，并且派生类定义了相同的函数。 为派生类的对象调用派生类中的函数，即使它是使用指针或对基类的引用来调用的。 



派生类中的函数仅在基类中的虚函数的类型相同时重写这些虚函数。 派生类中的函数不能只是与其返回类型中的基类的虚函数不同；参数列表也必须不同。

当使用指针或引用调用函数时，以下规则将适用：

- 根据为其调用的对象的基本类型来解析对虚函数的调用。
- 根据指针或引用的类型来解析对非虚函数的调用。



##### 虚函数与纯虚函数的区别

虚函数和纯虚函数在C++中都是实现多态的重要机制，但它们之间存在一些关键的区别：

* 实现与声明：

  - 虚函数：在基类中，虚函数可以有具体的实现（即函数体），也可以没有。如果提供了实现，那么派生类可以选择重写（override）它，也可以直接使用基类的实现。

  - 纯虚函数：纯虚函数只有声明而没有实现（即没有函数体）。它通过在函数声明的末尾添加`= 0`来指定。派生类必须提供纯虚函数的具体实现，否则派生类也将成为抽象类，不能被实例化。

- 抽象类：

  - 虚函数：含有至少一个虚函数的类不是抽象类，可以创建该类的对象。

  - 纯虚函数：含有至少一个纯虚函数的类被称为抽象类。抽象类不能直接实例化，即不能创建其对象，只能被用作基类。

- 目的与用途：

  - 虚函数：用于在派生类中提供一个或多个通用的实现，允许基类指针或引用调用派生类中重写的方法，实现运行时多态。

  - 纯虚函数：用于定义接口规范，强制派生类遵循一定的接口设计，确保派生类具有某些功能。

- 访问权限：

  - 虚函数：可以是公共（public）、受保护（protected）或私有（private）的。

  - 纯虚函数：通常也是公共的，但也可以是受保护的或私有的。然而，私有的纯虚函数在派生类中不会被调用，因为私有成员在派生类外部不可见。

- 在派生类中的重写：

  - 虚函数：在派生类中重写虚函数时，可以使用`override`关键字来明确指出该函数是重写基类中的虚函数，这有助于避免因误解基类中的函数而引入的错误。

  - 纯虚函数：在派生类中实现纯虚函数时，没有`override`关键字，因为纯虚函数没有默认实现，派生类必须提供实现。

总结来说，虚函数提供了一种运行时多态的机制，允许派生类根据需要重写基类的行为，而纯虚函数则是一种强制派生类实现特定接口的手段。虚函数可以在基类中有具体的实现，而纯虚函数则没有实现，必须在派生类中具体实现。含有纯虚函数的类是抽象类，不能直接实例化。



##### 哪些函数不能是虚函数

* 静态函数（static function）
* 构造函数（constructor）
* 友元函数（friend function）



##### 虚函数可以声明为`inline`吗？

在C++中，虚函数（virtual function）通常是用于实现多态的成员函数。虚函数允许派生类（derived class）重写（override）基类（base class）中定义的行为。而`inline`函数是一种编译器优化，用于减少函数调用的开销，通过在编译时将函数体插入到每个调用点来实现。

理论上，虚函数可以被声明为`inline`，但这在实践中并不常见，原因如下：

* **多态性与`inline`的冲突**： 虚函数的调用可能会在运行时通过动态绑定（dynamic dispatch）被重定向到派生类的重写版本。这意味着编译器不能保证在编译时就知道哪个函数体会被执行。而`inline`函数的目的是编译时的代码插入，这与虚函数的运行时多态性相冲突。
* **编译器优化**： 即使虚函数被声明为`inline`，编译器也可能不会将其内联。因为虚函数的调用可能会涉及到虚表（vtable）的查找和动态分派，这些操作通常不适合内联展开。
* **链接时优化（LTO）**： 即使虚函数被声明为`inline`，现代编译器可能会使用链接时优化（Link Time Optimization, LTO）来决定是否真正地将函数内联。LTO可以在编译单元（translation unit）之间进行优化，这可能会在链接阶段决定不内联某些`inline`虚函数。
* **标准库和最佳实践**： 标准库中的虚函数通常不会声明为`inline`，而且按照最佳实践，虚函数通常也不应该声明为`inline`，以避免上述潜在问题。

综上所述，虽然C++语言允许虚函数被声明为`inline`，但在实际编程中，这种做法并不常见，也不推荐。虚函数的主要目的是支持多态，而`inline`的主要目的是减少函数调用的开销，两者的目的和行为在某些方面是不兼容的。



##### 虚函数的代价？

虚函数的代价主要体现在两个方面

1.   运行时开销：虚函数的调用需要在运行时进行动态绑定，这会导致额外的开销，包括查找虚函数表、确定正确的函数地址
2.   内存占用：每个包含虚函数的类都需要维护一个虚函数表，这会占用额外的内存空间。

因此，在需要高性能的场景下，虚函数的代价可能会成为一个问题。在这种情况下，可以考虑使用其他的技术来实现多态性，例如模板、函数指针等。但是，在需要灵活性和可扩展性的场景下，虚函数仍然是一种非常有用的技术。



##### 构造函数和析构函数可以调用虚函数吗

构造函数和析构函数在某种程度上可以调用虚函数，但这种行为通常是不安全的，可能会引起未定义的行为或资源管理问题。下面是关于构造函数和析构函数调用虚函数的一些详细解释：

构造函数调用虚函数

在构造过程中，对象的类型逐渐从基类向派生类过渡。在构造函数的执行过程中，基类的构造函数首先被调用，然后是派生类的构造函数。在这个过程中，如果基类的构造函数调用了一个虚函数，那么只有基类的版本（如果存在的话）会被执行，因为此时派生类的部分还未被构造。

这是因为构造函数的执行过程中，对象的动态类型（即vtable中记录的类型信息）还没有完全设置好。虚函数的调用依赖于对象的动态类型，所以在构造函数中调用虚函数可能会导致调用错误的函数版本。

析构函数调用虚函数

析构函数的执行过程与构造函数相反，它是在对象生命周期结束时执行的。在析构过程中，派生类的析构函数首先被调用，然后是基类的析构函数。如果在派生类的析构函数中调用了一个虚函数，那么通常情况下，只有派生类的版本会被执行，因为此时对象的动态类型已经是派生类。

然而，如果在基类的析构函数中调用了一个虚函数，这通常是一个不好的做法，因为它可能会导致资源的二次释放或其他潜在的问题。例如，如果派生类中的资源已经在派生类的析构函数中被释放，那么在基类的析构函数中再次调用虚函数可能会导致未定义的行为。

为什么不应该在构造函数和析构函数中调用虚函数

- 资源管理：在构造函数中调用虚函数可能会导致资源的重复分配或释放，这可能会导致资源泄漏或其他错误。
- 初始化顺序：构造函数中的虚函数调用可能不会按照预期的派生类顺序执行，这可能会导致对象状态不一致。
- 未定义行为：在析构函数中调用虚函数可能会导致未定义行为，特别是如果资源已经被释放，再次调用可能会导致程序崩溃或其他错误。

结论

虽然在技术上可能可以在构造函数和析构函数中调用虚函数，但由于上述潜在问题，这种做法通常是不推荐的。更好的做法是在构造函数和析构函数中只调用非虚的成员函数，或者使用初始化列表来初始化成员变量，确保对象的类型安全和资源的正确管理。如果确实需要在构造函数或析构函数中调用虚函数，应该非常小心，并确保理解可能的后果。



#### 显式重写



#### 抽象类

##### Pimpl



### 组合



## 存储空间

#### 位域



## 访问控制

### 成员访问控制

| 访问类型    | 含义                                                         |
| :---------- | :----------------------------------------------------------- |
| `private`   | 声明为 `private` 的类成员只能由类的成员函数和友元（类或函数）使用。 |
| `protected` | 声明为 `protected` 的类成员可由类的成员函数和友元（类或函数）使用。 此外，它们还可由派生自该类的类使用。 |
| `public`    | 声明为 `public` 的类成员可由任意函数使用。                   |

访问控制有助于阻止通过不适当的方式使用对象。 在执行显式类型转换（强制转换）时，此保护将丢失。



### 派生类中的访问控制

两个因素控制基类的哪些成员可在派生类中访问；这些相同的因素控制对派生类中的继承成员的访问：

- 派生类是否使用 `public`访问说明符声明基类。
- 基类中对成员的访问权限如何。



#### 基类中的成员访问

| `private`                        | `protected`                                          | `public`                                              |
| :------------------------------- | :--------------------------------------------------- | :---------------------------------------------------- |
| 始终无法通过任何派生访问进行访问 | 如果使用 `private` 派生，则在派生类中为 `private`    | 如果使用 `private` 派生，则在派生类中为 `private`     |
|                                  | 如果使用 `protected`派生，则在派生类中为 `protected` | 如果使用 `protected` 派生，则在派生类中为 `protected` |
|                                  | 如果使用 `public` 派生，则在派生类中为 `protected`   | 如果使用 `public` 派生，则在派生类中为 `public`       |



#### public

语法

```c++
public:
   [member-list]
public base-class
```



当位于类成员列表前面时，`public` 关键字指定这些成员可从任何函数访问。 这适用于声明到下一个访问指示符或类的末尾的所有成员。

当位于基类名称前面时，`public` 关键字指定基类的公共和受保护成员分别是派生类的公共成员和受保护成员。

类中成员的默认访问是私有的。 结构或联合中成员的默认访问是公共的。

基类的默认访问对于类是私有的，而对于结构是公共的。 联合不能具有基类。



#### protected

语法

```c++
protected:
   [member-list]
protected base-class
```



`protected` 关键字指定对 member-list 中的类成员直到下一个访问说明符（`public` 或 `private`）或类定义的末尾的访问。 只能通过以下项使用声明为 `protected` 的类成员：

- 最初声明这些成员的类的成员函数。
- 最初声明这些成员的类的友元。
- 使用公共或受保护访问（派生自最初声明这些成员的类）派生的类。
- 也对受保护成员具有专用访问权限的以私有方式派生的直接类。

当位于基类的名称之前时，`protected` 关键字指定基类的公共成员和受保护成员是其派生类的受保护成员。

受保护成员不像 `private` 成员那样是专用的（仅对从中声明它们的类的成员可访问），但受保护成员也不像 `public` 成员那样是公开的（在任何函数中均可访问）。

同样被声明为 `static` 的受保护成员对派生类的任何友元或成员函数均是可访问的。 未被声明为 `static` 的受保护成员对派生类中的友元或成员函数是可访问的，但只能通过指向派生类的指针、对派生类的引用或派生类的对象来访问。



#### private

语法

```c++
private:
   [member-list]
private base-class
```



当位于类成员列表之前时，`private` 关键字指定这些成员仅可从成员函数和该类的友元中进行访问。 这适用于声明到下一个访问指示符或类的末尾的所有成员。

当位于基类的名称之前时，`private` 关键字指定基类的公共成员和受保护成员为派生类的私有成员。

类中成员的默认访问是私有的。 结构或联合中成员的默认访问是公共的。

基类的默认访问对于类是私有的，而对于结构是公共的。 联合不能具有基类。



#### friend