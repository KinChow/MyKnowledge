## 引用和指针的区别？

引用（reference）和指针（pointer）在C++中都是访问和操作内存中数据的机制，但它们有着本质的区别。以下是引用和指针之间的一些主要区别：

1. **定义和初始化**：
   - 引用必须在声明时初始化，它是一个已经存在变量的别名。一旦引用被初始化，它就不能被改变指向另一个变量。
   - 指针是一个变量，它存储另一个变量的内存地址。指针可以在声明后指向不同的变量，或者被赋予`nullptr`。
2. **内存地址操作**：
   - **引用**本身没有内存地址，它就是它所引用的变量的一个访问方式。你不能获取引用的地址，也不能改变引用所指向的目标。
   - **指针**存储有内存地址，可以通过指针进行地址运算，如增加指针的值来遍历数组等。
3. **空值表示**：
   - **引用**不能被初始化为`nullptr`，它总是指向一个有效的对象。
   - **指针**可以被初始化为`nullptr`，表示它不指向任何对象。
4. **语法**：
   - 使用引用时，你不需要使用解引用操作符`*`来访问引用所指向的数据，直接使用引用就像使用原始变量一样。
   - 使用指针时，你需要使用解引用操作符`*`来访问指针指向的数据。
5. **可变性**：
   - **引用**一旦被初始化后，它就始终指向那个特定的变量，不能被重新赋值指向另一个变量（尽管可以通过重新绑定来改变引用的初始绑定）。
   - **指针**可以随时被赋予新的地址，指向不同的变量或内存位置。
6. **函数参数**：
   - 传递引用给函数可以避免拷贝开销，并且函数内对引用的修改会直接反映到原始数据上。
   - 传递指针给函数时，需要考虑指针的生命周期和所有权问题，以及可能的空指针检查。
7. **内存管理**：
   - 使用**引用**时，不需要手动管理内存，引用只是原始数据的一个访问路径。
   - 使用**指针**时，可能需要手动管理内存，包括分配和释放内存（例如使用`new`和`delete`）。

总的来说，引用提供了一种安全、方便的方式来访问另一个变量，而指针则提供了更多的灵活性和控制能力，但同时也需要更多的注意和谨慎管理。在设计程序时，应根据具体需求和上下文来选择使用引用还是指针。





## 从汇编层去解释一下引用

在汇编层面，引用在C++中的实现本质上是指针的一种特殊表示。当在C++中声明一个引用时，底层的汇编代码会将其处理为指向目标变量的指针。然而，编译器会对引用进行优化，使得在大多数情况下，使用引用就像直接使用目标变量一样高效。

在汇编层面，引用并不具有独立的存储空间，它们不占用额外的内存。引用只是在汇编指令中被当作指向目标变量地址的指针。当你通过引用来访问或修改数据时，汇编指令会直接操作目标变量的内存地址。





## C++中的指针参数传递和引用参数传递

在C++中，函数参数可以通过值传递（pass by value）、指针传递（pass by pointer）和引用传递（pass by reference）三种方式进行传递。

* 指针参数传递（Pass by Pointer）：当函数参数通过指针传递时，实际上是将参数的地址传递给函数。函数接收到的是一个指向原始数据的指针，通过这个指针可以访问和修改原始数据。
* 引用参数传递（Pass by Reference）：当函数参数通过引用传递时，实际上是创建了原始数据的一个别名。函数接收到的是一个引用，对引用的任何操作都会直接反映到原始数据上。

* 区别

  - **语法**：指针传递需要在函数声明和定义中使用指针符号`*`，而引用传递则不需要。在调用指针传递的函数时，必须使用地址运算符`&`来传递变量的地址；引用传递则直接传递变量名即可。

  - **语义**：指针传递意味着函数接收到的是一个指向数据的指针，而引用传递意味着函数接收到的是数据的一个别名。指针需要解引用来访问数据，而引用则可以直接访问。

  - **性能**：指针传递和引用传递在性能上通常是相似的，因为编译器会对引用进行优化，使得引用的使用效率接近指针。然而，引用避免了指针的解引用操作，可能在某些情况下更高效。

  - **安全性**：引用不允许为空，而指针可以被赋予`nullptr`。此外，引用在使用前不需要进行空指针检查，因为它们不允许为空。

  - **可变性**：指针可以在函数内部重新指向另一个地址，而引用则始终指向同一个目标，不能被重新绑定到另一个变量。

在实际编程中，选择使用指针还是引用作为函数参数通常取决于具体的应用场景和设计考虑。引用提供了一种无指针操作的便捷方式，而指针则提供了更多的灵活性。





## 形参与实参的区别？

形参（Formal Parameter）和实参（Actual Parameter）是函数参数在不同上下文中的两种称呼，它们在函数调用过程中扮演不同的角色：

* **形参（Formal Parameter）**：

  - 形参是在函数定义中声明的变量，它们代表了函数调用时将要接收的值。

  - 形参是函数原型的一部分，它们在函数被声明和定义时指定。

  - 形参本身并不存储数据，它们是函数调用时传递给函数的值的占位符。

  - 在函数被调用之前，形参并不存在，它们仅在函数的上下文中有意义。

* **实参（Actual Parameter）**：

  - 实参是在函数调用时实际传递给函数的值或变量。
  - 实参可以是具体的值，也可以是变量的地址或引用。
  - 当函数被调用时，实参的值会被传递给对应的形参，从而在函数内部使用。
  - 实参在函数调用的语句中指定，它们在程序执行到函数调用点时才确定。





## static 的用法和作用？

在C++中，关键字 `static` 有多种用途，每种用途都有其特定的作用和上下文。以下是 `static` 的一些主要用法和作用：

* **静态局部变量**： 当 `static` 关键字用于函数内的局部变量时，它会改变该变量的生命周期。默认情况下，局部变量在函数调用结束时被销毁。但是，如果局部变量被声明为 `static`，它的生命周期会延长到程序结束，即使它的作用域是局部的。这意味着该变量在函数调用之间保持其值。
* **静态全局变量或类成员**： 当 `static` 关键字用于全局变量或类的静态成员时，它会限制变量或成员的链接性，使其成为内部链接（internal linkage）。这意味着这些变量或成员只在定义它们的文件内可见，不能被其他文件通过 `extern` 关键字访问。
* **静态类成员**： 在类中，静态成员变量属于类本身，而不是类的任何特定对象。这意味着无论创建了多少对象，静态成员变量只有一份副本。静态成员变量通常与静态成员函数一起使用，因为静态成员函数不能访问非静态成员。
* **静态函数**： 在C++中，函数不能被声明为 `static`，除非它是类的成员函数。类的静态成员函数可以独立于类的任何对象存在，它们不接收 `this` 指针，因此不能访问非静态成员。
* **静态类成员的初始化**： 静态类成员需要在类外进行初始化，即使它们被声明为 `const` 或 `constexpr`。初始化时不需要使用关键字 `static`，但必须在类定义的上下文之外进行。

`static` 关键字的使用提供了一种控制变量生命周期、作用域和链接性的方式，以及定义类级别的共享属性和方法。正确使用 `static` 可以提高代码的模块化和封装性。





## 静态变量什么时候初始化

在C++中，静态变量的初始化时机取决于变量的存储期和作用域。静态变量有两种主要类型：局部静态变量和全局（或类）静态变量。

* **静态局部变量**： 局部静态变量是在函数内部声明的，并且被声明为`static`。这些变量在程序启动时进行初始化，且在程序的整个运行期间只初始化一次。即使函数被多次调用，局部静态变量的值在函数调用之间是持久的。
* **静态全局（或类）变量**： 全局静态变量是在函数外部声明的，并且被声明为`static`。这些变量的初始化时机与局部静态变量相同，即在程序启动时进行初始化，且只初始化一次。全局静态变量的作用域被限制在声明它们的文件内，它们在其他文件中不可见。

对于这两种静态变量，初始化表达式在程序的启动过程中求值，通常在`main`函数执行之前完成。这是因为静态变量需要在程序的任何其他部分使用之前就已经初始化。初始化的确切顺序遵循一定的规则，特别是对于在不同文件中声明的全局静态变量，它们的初始化顺序是未定义的，除非它们在同一个文件中声明。

需要注意的是，如果静态变量是类成员，并且类有多个对象，那么每个对象都会有自己的静态成员变量副本。这些静态成员变量的初始化时机也是在程序启动时，且每个对象的静态成员变量独立于其他对象。





## const关键字

在C++中，`const`关键字是一个强大的特性，用于声明不可修改的变量、指针或引用。`const`的主要用途是定义只读数据，保证数据的安全性，并提供编译时的类型检查。以下是`const`关键字的一些主要用途和作用：

* **声明常量变量**： `const`可以用来声明一个编译时常量，其值在编译时已知，并且在程序运行期间不可更改。
* **声明常量指针**： `const`可以用来声明一个指向常量的指针，即指针指向的数据不可通过该指针修改。
* **声明指向常量的指针**： `const`也可以声明一个指针常量，即指针本身的值（指向的地址）在初始化后不可更改。
* **声明常量引用**： `const`可以用来声明一个常量引用，即引用本身不能绑定到新的值。
* **声明常成员函数**： `const`成员函数保证不会修改类的任何成员变量（除了`mutable`成员），并且可以在常量对象上调用。
* **模板参数的常量性**： `const`可以用于模板参数，确保模板只能被实例化为特定的常量类型。
* **类型常量性**： `const`可以用于类类型定义中，确保类型的大小和布局在编译时是已知的，这对于某些模板元编程技术非常重要。

`const`关键字的使用提高了代码的可读性和可维护性，它帮助程序员理解代码的意图，并防止意外的修改。在设计类和函数时，合理使用`const`可以使得代码更加健壮和安全。





## const 成员函数的理解和应用

在C++中，`const`成员函数是指在成员函数声明或定义的末尾加上`const`关键字的函数。这种成员函数不能修改类的任何成员变量（除了那些用`mutable`关键字声明的成员变量），也不能调用任何非常数成员函数。`const`成员函数的主要目的是保证对象的状态不会因为调用这些函数而改变，从而提高代码的安全性和可读性。

理解const成员函数：

* **不修改对象状态**： `const`成员函数承诺不会修改对象的任何成员变量（除了`mutable`成员），这意味着它们不会改变对象的数据成员。
* **可调用性**： `const`对象只能调用`const`成员函数，而非常数对象可以调用所有成员函数。
* **逻辑常量性**： `const`成员函数通常用于实现逻辑上的只读操作，例如获取对象的状态而不改变它。
* **重载决策**： `const`和非常数成员函数可以重载，即使它们的参数列表相同。这是因为`const`成员函数的调用上下文决定了它们是否可以接受`const`对象。

应用const成员函数：

* **获取对象状态**： `const`成员函数通常用于返回对象的状态信息
* **链式调用**： `const`成员函数可以用于支持链式调用，使得对象在一系列操作后仍然保持`const`
* **作为成员函数的默认行为**： 如果类的成员函数不需要修改对象状态，那么将它们声明为`const`是一个好习惯
* **与`const`对象一起使用**： `const`成员函数允许在`const`对象上调用，这使得对象可以在保持不变的情况下被操作

通过使用`const`成员函数，你可以向其他程序员传达你的类设计意图，即某些操作不会改变对象的状态。这有助于防止意外的副作用，并使得代码更容易理解和维护。





## 指针和 const 的用法

指向常量的指针（Const Pointer to Non-const Data）

```
const int* ptr;
```

这种类型的指针只能指向非常量（non-const）整型数据。你可以通过这个指针读取数据，但不能通过这个指针修改数据的值。这种用法适用于当你想要保护数据不被修改，同时又需要通过指针来访问数据时。



指向常量数据的指针（Pointer to Const Data）

```
int value = 10;
int* const ptr = &value;
```

这里的`ptr`是一个指向整型数据的常量指针。这意味着`ptr`指针本身的值（即它所指向的地址）不能改变，但通过`ptr`访问的数据是可以修改的。这种用法适用于当你想要固定指针指向的地址，但数据本身可以被修改时。



指向常量数据的常指针（Const Pointer to Const Data）

```
const int* const ptr = &value;
```

在这种情况下，`ptr`是一个指向常量整型数据的常量指针。这意味着你既不能通过`ptr`修改数据的值，也不能改变`ptr`所指向的地址。这种用法适用于当你想要通过指针保护数据不被修改，同时也不希望指针本身的指向地址发生变化时。





## mutable

在C++中，`mutable`是一个关键字，用于声明一个变量或类成员可以在`const`上下文中被修改。这通常用于那些即使在常量对象中也需要能够改变的成员变量。`mutable`的主要用途和作用如下：

* **修改常对象的成员**： 当你需要在`const`成员函数中修改某个成员变量时，可以将该成员声明为`mutable`。这样，即使对象被声明为`const`，`const`成员函数也可以修改这个`mutable`成员。
* **缓存和计数器**： `mutable`通常用于实现缓存或计数器等需要动态更新的成员变量，即使在常量对象中也是如此。
* **线程安全**： 在多线程环境中，`mutable`可以用来声明那些需要在不同线程中修改的成员变量，以实现线程安全。
* **优化**： `mutable`可以用于优化那些需要频繁修改的成员变量，以便在常量对象中避免不必要的重新分配或复制。

使用mutable时需要谨慎，因为它可能会使代码更难理解，特别是当const对象的行为不符合常量性的预期时。mutable成员变量的使用应该清晰地记录在文档中，以便其他程序员理解其行为。





## extern 用法？

在C++中，`extern`关键字用于声明一个变量或函数是在其他地方定义的，即告诉编译器该标识符（变量或函数名）的定义存在于程序的另一个文件或同一文件的其他地方。`extern`的主要作用是实现跨文件的全局变量或函数的访问。

以下是`extern`的一些主要用途：

* 跨文件共享全局变量：当你在多个文件中使用同一个全局变量时，可以在一个文件中定义变量，并在其他文件中使用`extern`来声明这个变量。
* 跨文件共享函数：`extern`也可以用于跨文件共享函数。当一个函数在一个文件中定义，在另一个文件中使用时，可以使用`extern`来声明函数原型。
* 链接C语言代码：`extern`关键字还常用于链接C语言代码。当你在C++程序中调用C语言代码时，可以使用`extern "C"`来告诉编译器使用C语言的链接方式。

注意事项

- 使用`extern`声明变量时，不需要（也不能）指定初始值，因为变量已经在其他地方定义了。
- `extern`只是声明，不是定义。变量或函数的定义应该在程序的某个地方出现。
- 在C++中，`extern`通常与头文件一起使用，以便在多个文件中共享全局变量或函数。
- 当使用`extern "C"`时，确保C++代码和C代码能够正确链接，且名称不会发生冲突。

正确使用`extern`可以提高代码的模块化，使得全局变量和函数可以在多个文件中共享和访问。





## int 转字符串？字符串转 int？

从`int`到字符串的转换

```c++
int num = 123;
std::string str = std::to_string(num);
```



从字符串到`int`的转换

```c++
std::string str = "123";
int num = std::stoi(str);
```





## strcat/strcpy/strncpy/memset/memcpy 的内部实现

```c++
// strcat函数用于连接两个字符串，它将第二个字符串追加到第一个字符串的末尾
char *strcat(char *dest, const char *src) {
    char *d = dest;
    while (*d) { /* Find the end of dest */ ++d; }
    while (*src) { /* Copy src to dest until the end of src */ *d++ = *src++; }
    *d = '\0'; /* Null-terminate the result */
    return dest;
}

// strcpy函数用于复制一个字符串到另一个位置。
char *strcpy(char *dest, const char *src) {
    char *d = dest;
    while (*src) { /* Copy each character until the end of src */ *d++ = *src++; }
    *d = '\0'; /* Null-terminate the result */
    return dest;
}

// strncpy函数用于复制指定数量的字符，或者直到遇到字符串的终止符\0。
char *strncpy(char *dest, const char *src, size_t n) {
    char *d = dest;
    while (n-- > 0 && *src) { /* Copy up to n characters or until the end of src */ *d++ = *src++; }
    while (n-- > 0) { /* Null-pad the rest of dest */ *d++ = '\0'; }
    return dest;
}

// memset函数用于将一块内存中的所有字节设置为特定的值。
void *memset(void *s, int c, size_t n) {
    char *p = (char *)s;
    while (n-- > 0) { /* Set each byte to the specified value */ *p++ = (char)c; }
    return s;
}

// memcpy函数用于从源内存区域复制一块数据到目标内存区域。
void *memcpy(void *dest, const void *src, size_t n) {
    char *d = (char *)dest;
    const char *s = (const char *)src;
    while (n-- > 0) { /* Copy each byte from src to dest */ *d++ = *s++; }
    return dest;
}
```





## 深拷贝与浅拷贝？

在C++中，深拷贝（deep copy）和浅拷贝（shallow copy）是两种不同的对象复制方式，它们在处理动态分配内存或包含指针成员的类对象时尤为重要。



浅拷贝（Shallow Copy）

浅拷贝指的是复制对象时，只复制对象中的值和指向动态分配内存的指针，而不复制指针所指向的实际内存内容。这意味着原始对象和拷贝对象将共享同一块动态分配的内存。

浅拷贝通常发生在以下几种情况：

1. 使用`memcpy`或`memmove`函数直接复制对象的内存。
2. 对象被复制到一个大小相同的数组或结构体中。
3. 通过简单的赋值操作复制对象，如`T obj2 = obj1;`，其中`T`是一个包含指针成员的类。

浅拷贝可能导致的问题是，当原始对象被销毁或修改时，拷贝对象中的数据也会受到影响，因为它们共享同一块内存。这可能导致未定义的行为，特别是当拷贝对象的生命周期超过原始对象时。



深拷贝（Deep Copy）

深拷贝指的是在复制对象时，不仅复制对象中的值，还复制指针所指向的内存内容。这样，拷贝对象将拥有自己的内存副本，不会与原始对象共享任何资源。

深拷贝可以通过以下几种方式实现：

1. 使用`new`和`delete`操作符为拷贝对象的每个指针成员分配新的内存，并复制原始指针指向的数据。
2. 使用`clone`或`copy`成员函数（如果类提供了这样的函数）来执行深拷贝。
3. 使用C++11的`std::move`（尽管它实际上执行的是移动操作，但在某些情况下可以模拟深拷贝的行为）。

深拷贝确保了拷贝对象的独立性，即使原始对象被修改或销毁，拷贝对象也不会受到影响。





## C++模板是什么，底层怎么实现的？

C++模板是一种强大的泛型编程机制，它允许程序员编写一段代码，这段代码可以与多种数据类型一起工作，而无需为每种数据类型编写重复的代码。模板可以用于函数和类，提供了一种编写通用、类型安全的代码的方法。

模板的主要特点是它在编译时进行类型参数的替换。当你使用一个模板函数或类时，编译器会根据你提供的类型参数生成一个新的函数或类的具体版本。这个过程称为模板实例化（template instantiation）。



底层实现：

模板的底层实现依赖于C++编译器的具体实现，但通常涉及以下几个步骤：

1. **模板参数**： 当你使用模板时，你需要提供一个或多个类型参数或非类型参数。例如，对于`std::vector<int>`，`int`就是类型参数。
2. **模板实例化**： 编译器在遇到模板定义时不会立即生成代码，而是等到模板被实例化时才生成。实例化是在编译时进行的，编译器会根据提供的类型参数创建一个新的函数或类的版本。
3. **代码生成**： 编译器将模板代码中的类型参数替换为具体的类型，并生成相应的机器代码。如果模板中使用了模板元编程技术，如递归模板实例化，编译器还会处理这些递归关系。
4. **链接**： 生成的代码与其他代码一起被链接到最终的可执行文件或库中。由于模板代码是在编译时生成的，所以链接器看到的已经是具体的函数或类实现。
5. **模板元编程**： 模板还可以用于模板元编程，这是一种在编译时执行计算的技术。通过递归模板实例化和特化（specialization），程序员可以在编译时生成复杂的数据结构和算法。



注意事项：

- 模板代码通常在头文件中定义，以便可以被多个源文件包含。
- 模板的实现（定义）必须在包含模板声明的头文件中可见，或者在源文件中定义模板。
- 模板的类型参数可以是任何合法的类型，包括基本类型、枚举、类、结构体等。
- 模板函数和类的性能通常与手写的针对每种类型的函数或类的性能相当，因为模板代码在编译时进行了优化。

总之，C++模板是一种强大的工具，它使得代码更加通用和灵活，同时保持了类型安全。通过模板，程序员可以编写一次代码，然后在多种数据类型上重用，从而减少代码重复和提高代码质量。





## C 语言 struct 和 C++ struct 区别

C语言和C++中的`struct`在很多方面是相似的，它们都可以用来定义一个包含多个不同或相同数据类型的复合数据类型。然而，它们之间也存在一些关键的区别：

* **函数成员**：

  - 在C语言中，`struct`不能包含函数。

  - 在C++中，`struct`可以包含成员函数，这使得`struct`可以像类（class）一样拥有行为。

* **继承**：

  - C语言的`struct`不支持继承。

  - C++的`struct`可以继承自其他`struct`或`class`，这是面向对象编程的一个重要特性。

- **构造函数和析构函数**：

  - C语言的`struct`不支持构造函数和析构函数。

  - C++的`struct`可以有构造函数和析构函数，这允许在创建和销毁`struct`实例时执行特定的代码。

- **运算符重载**：

  - C语言不支持运算符重载。

  - C++允许在`struct`中重载运算符，这使得`struct`可以使用像加法、减法等自定义的运算。

- **模板**：

  - C语言不支持模板。

  - C++中的`struct`可以是模板`struct`，这允许创建泛型数据结构，可以用于不同类型的数据。

- **内存对齐**：

  - C语言对内存对齐的要求比较宽松，`struct`的布局可能因编译器而异。

  - C++提供了`alignas`关键字，允许开发者指定`struct`成员的对齐方式，以确保跨平台的一致性和性能。

* **访问修饰符**：

  - C语言中，`struct`成员没有明确的访问修饰符。

  - C++中，可以使用`public`、`protected`和`private`关键字来修饰`struct`的成员。

总的来说，C++中的`struct`更加灵活，提供了面向对象的特性，而C语言中的`struct`则更简单，主要用于数据的简单组合。随着C++的发展，`class`和`struct`之间的界限变得模糊，`struct`在C++中更多地被用作类似于`class`的轻量级封装类型。





## 类成员初始化方式？构造函数的执行顺序？

在C++中，类成员可以通过多种方式进行初始化，而构造函数的执行顺序遵循特定的规则。下面分别介绍类成员的初始化方式和构造函数的执行顺序。



类成员初始化方式

类成员初始化可以在构造函数体内进行，也可以在类定义中使用初始化列表。以下是两种初始化方式的说明：

* **构造函数体内初始化**： 在构造函数的函数体内，可以直接对成员变量进行初始化。这种方式适用于需要运行时逻辑来初始化成员的情况。
* **初始化列表**： 使用初始化列表可以在构造函数声明之前对成员变量进行初始化。初始化列表使用冒号`:`后跟成员初始化，适用于编译时常量表达式或需要按特定顺序初始化的成员。



构造函数的执行顺序

当创建类的对象时，构造函数的执行顺序遵循以下规则：

1. **基类构造函数**： 基类的构造函数首先被调用，按照派生类继承列表中基类的顺序进行。如果有多个基类，则按照它们在派生类继承列表中的声明顺序进行初始化。
2. **成员变量初始化**： 派生类中的成员变量在基类构造函数之后初始化，按照它们在类定义中的声明顺序进行。
3. **派生类构造函数体**： 所有成员变量和基类构造函数执行完毕后，派生类的构造函数体开始执行。





## 为什么用成员初始化列表会快一些？

* **避免不必要的临时对象**： 当在构造函数体内使用赋值操作时，可能会隐式地创建临时对象，这些临时对象用于存储赋值操作的结果。例如，当你写`a = aValue;`时，`aValue`首先被用作创建一个临时对象，然后`a`被赋予这个临时对象的值。如果`a`是一个复杂的对象（如容器或类的实例），这个过程可能涉及到复制构造函数的调用，这可能会导致额外的性能开销。而在成员初始化列表中，对象是直接构造的，避免了临时对象的创建。
* **直接构造**： 在成员初始化列表中，成员变量是直接通过它们的构造函数来构造的，而不是通过赋值操作。这意味着对象可以在其原始位置直接构造，而不需要先构造一个临时对象然后再复制或移动到目标位置。
* **优化编译器生成的代码**： 编译器在处理成员初始化列表时，可以生成更优化的代码，因为它知道成员变量的确切类型和构造顺序。这可能会导致更高效的指令序列和更好的内存访问模式。
* **满足某些特殊要求**： 某些成员变量可能需要特定的初始化顺序，或者它们的类型可能不支持复制或赋值操作。在这些情况下，使用成员初始化列表是唯一可行的方法。
* **提高资源利用效率**： 对于动态分配的资源（如内存），使用成员初始化列表可以直接在构造函数中分配，而不需要在构造函数体内进行分配。这可以减少资源分配的开销，并可能提高资源的利用效率。

总的来说，成员初始化列表提供了一种更直接、更高效的方式来初始化类成员。然而，这并不意味着在所有情况下都应该使用成员初始化列表。对于简单的数据类型或不需要特定初始化顺序的成员变量，直接在构造函数体内赋值可能更简单、更直观。在设计类时，应该根据实际情况和性能要求来选择最合适的初始化方式。





## 成员列表初始化？

## 构造函数为什么不能为虚函数？析构函数为什么要虚函数？

## 析构函数的作用，如何起作用？

## 构造函数和析构函数可以调用虚函数吗，为什么

## 构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？

## 虚析构函数的作用，父类的析构函数是否要设置为虚函数？

## 构造函数析构函数可以调用虚函数吗？

## 构造函数析构函数可否抛出异常

## 类如何实现只能静态分配和只能动态分配

## 如果想将某个类用作基类，为什么该类必须定义而非声明？

## 什么情况会自动生成默认构造函数？

## 什么是类的继承？

## 什么是组合？

## 抽象基类为什么不能创建对象？

## 类什么时候会析构？

## 为什么友元函数必须在类内部声明？

## 介绍一下C++里面的多态？

## 用C语言实现C++的继承

## 继承机制中对象之间如何转换？指针和引用之间如何转换？

## 组合与继承优缺点？

## 左值右值

在C++中，左值（lvalue）和右值（rvalue）是两种表达式的类型，它们在语义上有着根本的区别，尤其是在C++11及以后的版本中，这种区别变得更加重要，因为它们都与移动语义（move semantics）和右值引用（rvalue reference）相关。

左值（Lvalue）

左值是指那些可以出现在赋值表达式左侧的表达式，它们指向内存中的一个固定位置，通常是一个对象。左值的名称来源于它们可以出现在赋值操作符（如`=`）的左侧。左值具有以下特点：

- 可以被赋值。
- 通常指向对象的完整生命周期。
- 可以取地址。



右值（Rvalue）

右值是指那些只能出现在赋值表达式右侧的表达式，或者不能出现在赋值表达式的左侧。右值通常表示临时的对象或即将销毁的对象。右值的名称来源于它们通常出现在赋值操作符的右侧。右值具有以下特点：

- 不能被赋值。
- 通常指向临时对象或即将销毁的对象。
- 不能取地址（除非通过特定的语法，如`std::move`）。





## `std::move`和`static_cast<T&&>`区别

`std::move`和`static_cast<T&&>`都可以用来实现移动语义，但它们在语法和使用上有一些区别：



`std::move`

`std::move`是一个标准库函数，它接受一个左值引用作为参数，并将其转换为右值引用。这个操作通常用于实现资源的移动，例如，当一个对象需要从一个地方移动到另一个地方时，可以使用`std::move`来避免不必要的复制。



`static_cast<T&&>`

`static_cast<T&&>`是C++11引入的类型转换操作符，它可以将一个表达式转换为右值引用。这种转换通常用于创建一个右值引用，以便可以将其作为右值传递给一个接受右值引用的函数或操作。



区别

- `std::move`专门用于将左值转换为右值引用，以便实现移动语义。它通常用于赋值操作或函数调用中，以表明资源的移动。
- `static_cast<T&&>`是一个更通用的类型转换，它可以将任何表达式转换为右值引用。它不仅限于移动操作，也可以用于其他需要右值引用的场景。

在大多数情况下，当你想要移动一个资源时，应该使用`std::move`。如果你需要一个右值引用来进行模板元编程或其他高级类型操作，那么`static_cast<T&&>`可能是更合适的选择。在实际编程中，`std::move`更常用，因为它的语义更明确，且易于理解。





## 移动构造函数

## C语言的编译链接过程？

## vector 与list 的区别与应用？怎么找某 vector 或者 list 的倒数第二个元素

## STL vector的实现，删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？

## 容器内部删除一个元素

## STL 迭代器如何实现

## set 与 hash_set 的区别

## hashmap 与 map 的区别

## map、set 是怎么实现的，红黑树是怎么能够同时实现这两种容器？为什么使用红黑树？

## 如何在共享内存上使用stl标准库？

## map 插入方式有几种？

## STL 中 unordered_map（hash_map）和map 的区别，hash_map 如何解决冲突以及扩容

## vector 越界访问下标，map 越界访问下标？

## vector 删除元素时会不会释放空间？

## map[]与 find 的区别？

## STL 中list 与 queue 之间的区别

## STL 中的 allocator deallocator

## STL 中 hash_map 扩容发生什么？

## map 如何创建？

## vector 的增加删除都是怎么做的？为什么是1.5倍？

## 函数指针？

## 说说你对c和c++的看法，c和c++的区别？

## c/c++的内存分配，详细说一下栈、堆、静态存储区？

## 堆与栈的区别？

## 野指针是什么？如何检测内存泄漏？

## 悬空指针和野指针有什么区别？

## 内存泄漏

## new 和malloc的区别？

## delete p/delete[] p/allocator

## new 和delete 的实现原理，delete 是如何知道释放内存的大小的

## malloc 申请的存储空间能用 delete 释放吗

## malloc 与free 的实现原理

`malloc` 和 `free` 是C语言标准库中用于动态内存分配和释放的函数。它们的实现原理通常依赖于操作系统和运行时环境，但大多数实现遵循一些通用的策略。以下是`malloc`和`free`的一般实现原理：

malloc 的实现原理

1. **内存池**：
   `malloc`通常使用一个内存池来管理可用的内存块。这个内存池可以是一块大的连续内存区域，也可以是由多个较小的内存块组成的链表或树状结构。

2. **分区**：
   当`malloc`被调用时，它会尝试在内存池中找到一个足够大的空闲分区来满足请求的内存大小。如果当前的内存池中没有足够大的连续空闲块，`malloc`可能会请求更多的内存从操作系统中获取。

3. **对齐**：
   为了提高内存访问的效率，`malloc`通常会对分配的内存块进行对齐，使其大小符合特定硬件平台的要求。

4. **头部信息**：
   在分配的内存块前，`malloc`可能会添加一些头部信息，用于存储分配块的大小、状态和其他管理信息。

5. **合并策略**：
   为了减少内存碎片，`malloc`可能会采用一些策略来合并相邻的空闲块。



free 的实现原理

1. **标记为空闲**：
   当`free`被调用时，它会将指定的内存块标记为空闲状态，并更新内存池的管理信息。

2. **合并空闲块**：
   `free`可能会尝试将释放的内存块与相邻的空闲块合并，以形成更大的空闲块，减少内存碎片。

3. **返回给操作系统**：
   在某些情况下，如果内存池中的空闲内存过多，`free`可能会将一部分内存返回给操作系统，以便操作系统可以将其用于其他目的。

4. **延迟释放**：
   `free`可能会采用延迟释放的策略，即不立即释放内存，而是等到适当的时候再进行释放，以提高性能。



注意事项

- **内存碎片**：
  频繁的`malloc`和`free`操作可能会导致内存碎片化，影响内存分配的效率。一些`malloc`的实现采用了高级的内存管理算法来最小化这个问题。

- **内存泄漏**：
  如果程序员没有正确地匹配`malloc`和`free`调用，可能会导致内存泄漏。为了避免这种情况，可以使用工具来检测内存泄漏，或者使用智能指针等自动内存管理技术。

- **并发访问**：
  在多线程环境中，`malloc`和`free`的调用需要是线程安全的，以防止多个线程同时修改内存池的状态。

- **性能**：
  `malloc`和`free`的性能取决于它们的实现和使用模式。在性能敏感的应用中，可能需要使用特定的内存分配策略或自定义的内存管理器。

`malloc`和`free`的具体实现可能因编译器、操作系统和硬件平台的不同而有所差异。一些高级的内存分配器还可能包括缓存、预分配、延迟释放和其他优化技术来提高性能和减少内存碎片。在实际编程中，了解这些原理有助于更好地管理内存和优化程序性能。





## malloc、realloc、calloc的区别

## `__stdcall` 和`__cdecl` 的区别

`__stdcall`和`__cdecl`是两种不同的函数调用约定（calling conventions），它们定义了函数参数如何被传递（通过栈或寄存器），以及谁负责清理栈（调用者还是被调用者）。这些约定主要在C和C++的Windows平台代码中使用，尤其是在编写与Windows API交互的代码时。下面是`__stdcall`和`__cdecl`之间的主要区别：

* `__cdecl`

  * **参数传递**：在`__cdecl`约定中，函数参数从右到左的顺序被推送到栈上，这意味着函数内部可以访问所有的参数，不管参数的数量。

  * **栈清理**：`__cdecl`约定要求调用者负责在函数调用后清理栈。这通常通过`add esp, x`指令完成，其中`x`是参数所占用的字节数。

  * **兼容性**：`__cdecl`是C和C++的默认调用约定，因此它具有很好的兼容性，适用于大多数情况。

* `__stdcall`

  * **参数传递**：`__stdcall`（也称为`StdCall`）约定中，函数参数从右到左的顺序被推送到栈上，与`__cdecl`相同。但是，如果函数调用失败，`__stdcall`约定要求被调用者（函数本身）清理栈。

  * **栈清理**：在`__stdcall`约定中，函数的前两个字节包含了参数的大小，这允许被调用者知道需要清理多少栈空间。因此，被调用者负责在函数返回后清理栈。

  * **跨语言调用**：`__stdcall`约定通常用于需要从不同的编程语言（如C++、VB、Delphi等）调用函数的情况，因为它提供了一致的接口。

* 总结

  - **参数传递**：`__cdecl`和`__stdcall`在参数传递方面是相同的。

  - **栈清理**：这是两者最主要的区别。`__cdecl`要求调用者清理栈，而`__stdcall`要求被调用者清理栈。

  - **使用场景**：`__cdecl`是默认的调用约定，适用于大多数C和C++函数。`__stdcall`通常用于与Windows API交互，或者在需要跨语言调用时使用。


在编写跨平台代码或不需要特定调用约定的代码时，通常建议使用默认的`__cdecl`。然而，在Windows平台编程，特别是与Windows API交互时，`__stdcall`是更常见的选择，因为它提供了一种与Windows API兼容的调用方式。



## 使用智能指针管理内存资源，RAII

## 手写实现智能指针类

手写实现一个简单的智能指针类可以让我们更好地理解智能指针的工作原理。下面是一个简单的`UniquePtr`类的实现，它模仿了C++标准库中的`std::unique_ptr`的基本功能。

```cpp
#include <iostream>
#include <stdexcept>

template<typename T>
class UniquePtr {
public:
    // 构造函数
    UniquePtr() : ptr_(nullptr) {}
    explicit UniquePtr(T* ptr) : ptr_(ptr) {}

    // 拷贝构造函数（删除）
    UniquePtr(const UniquePtr& other) = delete;

    // 赋值操作符（删除）
    UniquePtr& operator=(const UniquePtr& other) = delete;

    // 移动构造函数
    UniquePtr(UniquePtr&& other) noexcept : ptr_(other.ptr_) {
        other.ptr_ = nullptr;
    }

    // 移动赋值操作符
    UniquePtr& operator=(UniquePtr&& other) noexcept {
        if (this != &other) {
            delete ptr_;
            ptr_ = other.ptr_;
            other.ptr_ = nullptr;
        }
        return *this;
    }

    // 解引用操作符
    T& operator*() const {
        return *ptr_;
    }

    // 箭头操作符
    T* operator->() const {
        return ptr_;
    }

    // 获取原始指针
    T* get() const {
        return ptr_;
    }

    // 重置智能指针
    void reset(T* ptr = nullptr) {
        T* old_ptr = ptr_;
        ptr_ = ptr;
        delete old_ptr;
    }

    // 析构函数
    ~UniquePtr() {
        delete ptr_;
    }

private:
    T* ptr_;
};

int main() {
    UniquePtr<int> ptr1(new int(10));
    *ptr1 = 20; // 解引用操作
    std::cout << "Value: " << *ptr1 << std::endl; // 解引用操作

    UniquePtr<int> ptr2 = std::move(ptr1); // 移动操作
    std::cout << "Value after move: " << *ptr2 << std::endl;

    return 0;
}
```

这个`UniquePtr`类实现了以下功能：

1. **构造函数**：提供了默认构造函数和接受原始指针的构造函数。
2. **拷贝构造函数和赋值操作符**：被删除，以避免双重拥有同一资源。
3. **移动构造函数和移动赋值操作符**：允许转移所有权，而不是复制资源。
4. **解引用操作符**：提供了对管理对象的访问。
5. **箭头操作符**：提供了对管理对象的指针访问。
6. **获取原始指针**：提供了获取内部存储的原始指针的方法。
7. **重置**：允许更改智能指针所管理的对象。
8. **析构函数**：当智能指针超出作用域时，自动释放管理的资源。

请注意，这个简单的`UniquePtr`类没有实现`std::unique_ptr`的所有功能，例如自定义删除器或与标准库的其他组件的集成。此外，这个实现也没有考虑线程安全性。在多线程环境中，可能需要使用互斥锁来保护对智能指针的并发访问。





## 内存对齐？位域？

## 结构体变量比较是否相等

结构体变量的比较通常遵循以下规则：

1. **成员逐个比较**：两个结构体变量相等当且仅当它们的所有对应成员都相等。这意味着你需要逐个比较每个成员的值。
2. **成员顺序**：结构体成员的比较顺序是根据它们在结构体定义中的声明顺序来的。
3. **位字段（Bit Fields）**：如果结构体包含位字段（bit fields），比较时需要特别注意，因为位字段可能不会占用整个存储单元（例如，一个声明为 `int` 类型的位字段可能只占用32位，而实际上它只使用了其中的几位）。
4. **自定义比较函数**：如果你需要自定义结构体变量的比较逻辑，你可以为结构体定义比较操作符重载函数（如 `operator==` 和 `operator!=`）。





## 位运算

## 为什么内存对齐

## 函数调用过程栈的变化，返回值和参数变量哪个先入栈？

## 怎样判断两个浮点数是否相等？

## 宏定义一个取两个数中较大值的功能

## define、const、typedef、inline 使用方法？

## printf 实现原理？

## #include 的顺序以及尖括号和双引号的区别

* 使用<>括起来的头文件通常是标准库头文件或系统头文件，编译器会在系统路径下寻找这些头文件。
* 使用""括起来的头文件通常是用户自定义的头文件或者位于当前目录下的头文件，编译器会先在当前目录下查找这些头文件，如果找不到再去系统路径下查找。

头文件的包含顺序很重要，一般来说应该先包含系统头文件，再包含自定义头文件。这样可以避免一些不必要的编译错误
另外，头文件中可能会包含其他头文件，这就需要开发者注意头文件的依赖关系，避免出现循环依赖的情况。



## lambda 函数





## hello world 程序开始到打印到屏幕上的全过程？





## 模板类和模板函数的区别是什么？





## 为什么模板类一般都是放在一个h文件中





## C++中类成员的访问权限和继承权限问题。





## cout 和 printf 有什么区别？





## 重载运算符？





## 函数重载函数匹配原则

函数重载是C++中的一个重要特性，它允许程序员定义多个具有相同函数名但参数列表不同的函数。当调用一个重载函数时，编译器会根据调用的上下文和提供的参数来匹配最合适的函数版本。函数重载的匹配原则遵循以下步骤：

1. **参数类型匹配**： 编译器首先会检查提供的参数类型是否与候选函数的参数类型相匹配。这可能包括自动类型转换，如将`int`转换为`double`或使用`static_cast`进行显式类型转换。
2. **参数数量匹配**： 提供的参数数量必须与候选函数的参数数量相同。如果参数数量不匹配，该函数将不会被考虑。
3. **最佳匹配原则**： 如果有多个候选函数与参数类型匹配，编译器将尝试找到“最佳匹配”。最佳匹配意味着对于每个参数，候选函数的参数类型要么与实际参数类型完全相同，要么可以接受从实际参数类型到函数参数类型的隐式转换。
4. **用户定义的转换（UDC）**： 如果候选函数使用了用户定义的转换（如构造函数或转换操作符），编译器会考虑这些转换作为匹配的一部分。用户定义的转换可能会影响最佳匹配的选择。
5. **函数参数的const-correctness**： 如果候选函数的参数声明为`const`，那么只有当实际参数也是`const`时，或者可以隐式转换为`const`时，该函数才会被考虑。例如，`const int&`参数可以接受`int`、`const int`或`volatile int`类型的参数。
6. **重载解析的失败**： 如果编译器无法找到任何匹配的重载函数，或者有多个函数都是最佳匹配，编译器将报告一个错误。





## 定义和声明的区别





## C++类型四种转换





## 全局变量和 static 变量的区别





## 静态成员与普通成员的区别





## 说一下理解 ifdef endif





## 隐式转换，如何消除隐式转换？

1. **使用显式类型转换**： 通过显式类型转换（如`static_cast`、`dynamic_cast`、`reinterpret_cast`和`const_cast`）来明确指示类型转换的意图，这样可以避免隐式转换。
2. **避免使用构造函数进行转换**： 如果类的构造函数可以接受某些特定类型的参数，C++可能会使用这些构造函数来进行隐式转换。通过使这些构造函数成为`explicit`可以防止隐式转换。





## 虚函数的内存结构，那菱形继承的虚函数内存结构呢





## 多继承的优缺点，作为一个开发者怎么看待多继承

多继承是面向对象编程中的一个特性，它允许一个类同时继承多个基类。C++ 是支持多继承的编程语言之一。多继承带来了一些优点，但同时也引入了复杂性和潜在的问题。以下是多继承的一些优缺点，以及作为开发者应如何看待它：

优点：

1. **代码复用**：多继承使得类可以继承多个基类中的属性和方法，从而实现代码的复用。

2. **灵活性**：开发者可以从多个不相关的类中继承所需的功能，创建出具有特定行为的派生类。

3. **接口继承**：多继承允许类继承接口（尽管在C++中接口通常通过抽象类实现），这有助于实现类似接口的多态行为。

4. **组合多个概念**：多继承允许将来自不同基类的概念组合到一个派生类中，这在某些设计中是有用的。

缺点：

1. **复杂性**：多继承增加了代码的复杂性，尤其是当基类之间存在重叠或继承层次结构复杂时。

2. **歧义**：当多个基类中有相同名称的成员时，会产生歧义，需要通过名称隐藏或名称修饰来解决。

3. **菱形继承问题**：当两个基类继承自同一个类，而派生类继承自这两个基类时，会出现菱形继承问题，导致构造函数调用和析构顺序的混乱。

4. **维护困难**：多继承可能导致类的维护变得更加困难，因为开发者需要理解所有基类的实现细节。

5. **性能开销**：在某些情况下，多继承可能会引入额外的性能开销，尤其是在虚函数表的管理和运行时多态解析方面。



作为开发者的看法：

作为开发者，应该谨慎使用多继承。在决定使用多继承之前，应该考虑以下几点：

1. **设计清晰性**：确保多继承的使用能够提高代码的清晰性和可维护性，而不是增加复杂性。

2. **替代方案**：考虑是否有其他设计模式或技术可以实现相同的目标，例如组合（Composition）或接口继承。

3. **继承的目的**：应该明确继承的目的。如果继承是为了实现多态和代码复用，那么多继承可能是合适的。但如果是为了组合不同类的功能，可能更适合使用组合。

4. **菱形继承问题**：在使用多继承时，要特别注意避免菱形继承问题，或者在必要时使用虚拟继承来解决构造函数和析构顺序的问题。

5. **文档和注释**：在使用多继承的代码中，应该提供充分的文档和注释，以帮助其他开发者理解继承结构和意图。

总之，多继承是一个强大的特性，但它也带来了一些挑战和潜在的问题。作为开发者，应该在充分理解其优缺点的基础上，根据具体的项目需求和设计目标来决定是否使用多继承。在某些情况下，避免使用多继承可能会带来更简单、更易于维护的代码。





## 迭代器++it/it++哪个好，为什么





## C++如何处理多个异常的？





## 模板和实现可不可以不写在一个文件里面？为什么？

可以的，模板和实现可以分别写在不同的文件里。在C++中，模板是一种特殊的函数或类型，它可以让你编写通用的代码，可以在不同的数据类型上编译和链接。模板可以提高代码的复用性和可读性，但它们也会增加代码的复杂性。因此，将模板和实现分开写可以让你更好地管理代码的复杂性，并使代码更易于维护和更新。在实际开发中，你可以将模板定义放在一个单独的文件中，然后在需要使用模板的地方包含该文件即可。这样可以将模板和实现分开，使代码更加清晰和易于管理。





## 在成员函数中调用 delete this 会出现什么问题？对象还可以使用吗？





## 智能指针的作用

智能指针是C++中的一种对象，其主要作用是管理动态分配的内存，以确保资源得到正确和自动的释放，从而避免内存泄漏和其他资源管理问题。智能指针提供了一种安全、方便且高效的方式来处理动态内存分配的问题。

以下是智能指针的主要作用和优点：

* 自动内存管理

  * 智能指针在对象不再使用时自动释放其占用的内存。这意味着，当智能指针的实例（对象）超出作用域或被删除时，它所管理的内存也会被自动释放。这消除了忘记手动调用`delete`操作的风险。

* 防止内存泄漏

  * 由于智能指针会自动释放管理的内存，因此它们有助于防止内存泄漏。内存泄漏通常是由于程序员忘记释放不再需要的内存导致的，智能指针通过自动管理内存的生命周期来解决这个问题。

* 所有权语义

  * 智能指针提供了所有权语义，这意味着智能指针可以拥有它所指向的对象。当智能指针被复制时，它不会复制对象本身，而是复制对对象的所有权。这意味着所有者（原始智能指针）将放弃对对象的所有权，新的智能指针将成为对象的新所有者。

* 支持RAII（Resource Acquisition Is Initialization）

  * RAII是一种编程技术，它要求资源的获取和释放与对象的生命周期绑定。智能指针是RAII的一个很好的例子，因为它们在构造时获取资源，在析构时释放资源。

* 支持多线程

  * 一些智能指针（如`std::shared_ptr`）支持多线程环境，允许多个线程安全地共享同一个资源。

* 与标准库的集成

  * 智能指针与C++标准库紧密集成，使得它们可以无缝地与STL容器、算法和其他库组件一起使用。

* 支持自定义删除器

  * 智能指针允许用户指定自定义删除器，这使得它们不仅可以管理内存，还可以管理其他类型的资源，如文件句柄、网络连接等。

* 智能指针的类型

  - `std::unique_ptr`：提供独占所有权的智能指针，不允许复制（除了通过`std::move`进行移动）。

  - `std::shared_ptr`：提供共享所有权的智能指针，允许多个指针共享同一个对象。

  - `std::weak_ptr`：提供弱引用的智能指针，不拥有对象，但可以观察对象的存在。




注意事项

虽然智能指针提供了许多优点，但它们也有一些限制和注意事项：

- 智能指针增加了程序的复杂性，不当使用可能导致资源管理问题。
- 智能指针的性能开销通常很小，但在性能敏感的应用中，需要考虑其影响。
- 智能指针不适用于所有场景，有时原始指针更加合适，特别是在需要手动管理内存的情况下。

总之，智能指针是C++中管理动态内存的强大工具，它们通过自动释放资源来简化内存管理，提高代码的安全性和可维护性。正确使用智能指针可以显著减少内存泄漏和其他资源管理错误。





## `auto_ptr`作用

`auto_ptr`是C++标准库中曾经提供的一种智能指针，其主要作用是自动管理动态分配的内存，确保资源得到正确释放。`auto_ptr`通过拥有权语义（ownership semantics）来管理内存，当`auto_ptr`对象的生命周期结束时，它会自动释放其管理的内存。这种机制有助于防止内存泄漏。



`auto_ptr`的作用：

* **自动内存管理**：`auto_ptr`可以自动释放它所指向的动态内存，减少程序员手动管理内存的负担。
* **所有权转移**：`auto_ptr`支持所有权转移，即当`auto_ptr`被复制或赋值给另一个`auto_ptr`时，原始`auto_ptr`会失去对内存的所有权，新`auto_ptr`获得所有权。
* **异常安全**：即使在异常发生时，`auto_ptr`也能保证内存被正确释放，因为它的析构函数会在对象销毁时自动调用。



为什么`auto_ptr`被弃用：

尽管`auto_ptr`提供了一些有用的功能，但它在C++11中被弃用的原因在于它的设计存在一些问题和局限性：

* **不支持数组**：`auto_ptr`不能用来管理动态分配的数组，这限制了它的使用场景。
* **浅拷贝问题**：`auto_ptr`的拷贝操作实际上是一个所有权转移，这意味着原始`auto_ptr`在拷贝后不再拥有内存。这与通常的拷贝行为（深拷贝）不同，容易导致混淆和错误。
* **安全性问题**：`auto_ptr`的所有权转移特性使得它在某些情况下不够安全，例如，当`auto_ptr`作为函数参数按值传递时，原始指针可能会失去对资源的控制，导致资源泄露或二次释放的风险。
* **`unique_ptr`的引入**：C++11引入了新的智能指针`unique_ptr`，它提供了更好的安全性和更丰富的功能，包括对数组的支持和自定义删除器的能力。`unique_ptr`没有`auto_ptr`的浅拷贝问题，并且提供了`move`语义，使得资源的转移更加清晰和安全。

由于上述原因，`auto_ptr`在C++11中被标记为弃用，并推荐使用`unique_ptr`作为替代。`unique_ptr`不仅解决了`auto_ptr`的问题，还提供了更现代的C++特性，如移动语义，使其成为更安全、更灵活的智能指针选择。





## class、union、struct 的区别





## 动态联编与静态联编

动态联编和静态联编是计算机编程中的两种不同的函数调用方式。

* 静态联编是在编译时确定函数调用的地址，即编译器会在编译时将函数的地址与函数调用语句绑定在一起，这样在程序运行时就可以直接调用该地址，因此静态联编的速度比较快，但是可扩展性不够灵活，因为如果要调用不同的函数，需要重新编译整个程序。
* 动态联编是在程序运行时才确定函数调用的地址，即编译器只在编译时检查函数名是否正确，而不确定函数的地址，待程序运行时再根据函数名寻找函数的地址，这样可以在运行时动态地调用不同的函数，因此动态联编的可扩展性比较好，但是速度相对较慢。

总的来说，静态联编适用于函数调用频繁，但是函数不会发生变化的情况，而动态联编适用于函数调用不频繁，但是函数可能会发生变化的情况。





## 动态编译与静态编译

动态编译（Dynamic Compilation）和静态编译（Static Compilation）是两种不同的编译方式，它们在编译时机、编译内容以及最终生成的可执行文件的特性上有所区别。

动态编译（Dynamic Compilation）

1. **编译时机**：
   动态编译通常发生在程序运行时或者在需要时进行。编译器在运行时将源代码编译成机器代码，然后立即执行。

2. **编译内容**：
   动态编译器（如JIT编译器）通常编译的是程序的一部分或全部，这取决于程序的设计和运行时的需求。

3. **可执行文件特性**：
   动态编译不生成传统的可执行文件。相反，编译后的代码直接在内存中执行，这使得程序的启动和执行速度可能更快。

4. **优点**：
   - 可以实时优化代码，根据运行时的数据和环境进行调整。
   - 允许程序在运行时动态加载和执行新代码。

5. **缺点**：
   - 需要运行时环境支持编译器。
   - 可能存在安全风险，因为动态编译的代码可以修改程序的行为。



静态编译（Static Compilation）

1. **编译时机**：
   静态编译通常在程序开发阶段完成，即在程序部署之前。编译器将源代码编译成机器代码，生成可执行文件。

2. **编译内容**：
   静态编译器编译的是整个程序或库的所有源代码，生成的是最终的二进制文件。

3. **可执行文件特性**：
   静态编译生成的是独立的可执行文件，包含了运行程序所需的所有机器代码和资源。这些文件可以在没有编译器的环境中运行。

4. **优点**：
   - 生成的可执行文件可以在任何支持该文件格式的系统上运行，无需源代码。
   - 通常具有更好的安全性，因为编译后的代码不易被修改。

5. **缺点**：
   - 无法根据运行时环境进行优化。
   - 可执行文件通常比动态编译的代码大，因为包含了所有可能用到的代码和资源。



总结

动态编译和静态编译各有优势和适用场景。动态编译适合于需要实时优化和动态加载代码的应用，如一些脚本语言的执行和某些高性能计算任务。而静态编译则适合于需要生成稳定、独立可执行文件的场景，如软件开发和系统部署。

在实际应用中，两种编译方式也可以结合使用。例如，一些程序可能使用静态编译生成核心组件，同时使用动态编译来处理可配置或可扩展的部分。这样可以兼顾运行效率和部署便利性。





## 动态链接和静态链接区别

动态链接（Dynamic Linking）和静态链接（Static Linking）是编译和链接程序时使用的两种不同的方法。它们在程序的构建、运行和内存占用方面有着显著的差异。

静态链接

1. **链接时机**：
   静态链接发生在程序编译时。编译器将程序和所有需要的库的代码合并成一个单一的可执行文件。

2. **可执行文件**：
   静态链接生成的可执行文件包含了程序运行所需的所有代码，包括静态库中的代码。

3. **运行时依赖**：
   由于所有需要的代码都已经包含在可执行文件中，静态链接的程序不需要在运行时加载外部库。

4. **优点**：
   - 程序部署简单，因为不需要安装额外的库文件。
   - 程序启动可能更快，因为不需要加载外部依赖。

5. **缺点**：
   - 可执行文件体积较大，因为它包含了所有静态库的代码。
   - 如果多个程序使用相同的静态库，会浪费磁盘空间和内存，因为每个程序都包含了库的副本。



动态链接

1. **链接时机**：
   动态链接发生在程序运行时。程序在运行时会加载所需的共享库（Shared Libraries）或动态链接库（Dynamic Link Libraries）。

2. **可执行文件**：
   动态链接生成的可执行文件不包含库的代码，只包含对库的引用和调用接口。

3. **运行时依赖**：
   程序在运行时需要加载相应的动态库。这些库在操作系统的库路径中或者由程序指定的路径中查找。

4. **优点**：
   - 节省磁盘空间和内存，因为多个程序可以共享同一个库文件。
   - 易于程序更新和维护，只需替换动态库文件即可。

5. **缺点**：
   - 程序部署可能更复杂，因为需要确保正确的动态库可用。
   - 程序启动可能稍慢，因为需要在运行时加载和链接库。



总结

选择动态链接还是静态链接取决于具体的应用场景。静态链接适合于那些需要独立运行、易于部署的应用程序，而动态链接适合于那些需要节省空间、便于更新和共享库资源的应用程序。

在实际开发中，开发者可能会根据不同的库和应用程序的需求，选择适当的链接方式。例如，操作系统和大型应用程序通常会使用动态链接，以便于库的更新和共享；而一些小型工具和嵌入式应用程序可能会使用静态链接，以简化部署和提高可移植性。





## 在不使用额外空间的情况下，交换两个数？

在不使用额外空间的情况下交换两个数，可以通过数学运算或指针操作来实现。以下是两种常见的方法：



方法1：使用数学运算（加法和减法）

对于整数类型的变量，可以使用加法和减法来交换它们的值。这种方法适用于数值类型的数据（如 `int`、`float` 等）。

```cpp
int a = 5;
int b = 10;

a = a + b; // a 现在为 15 (5 + 10)
b = a - b; // b 现在为 5 (15 - 10)
a = a - b; // a 现在为 10 (15 - 5)
```

然而，这种方法有一个潜在的问题：如果数值非常大，可能会导致溢出。因此，对于可能超出数值类型范围的情况，应避免使用这种方法。



方法2：使用指针（仅限同一类型）

如果你有两个指向相同类型数据的指针（或者两个变量的地址），可以通过指针来交换它们所指向的数据。

```cpp
int a = 5;
int b = 10;

// 假设 p1 和 p2 是指向 int 的指针
int* p1 = &a;
int* p2 = &b;

// 交换指针指向的值
*p1 = *p1 ^ *p2; // a 和 b 的原始值异或
*p2 = *p1 ^ *p2; // 再次异或，恢复 a 的原始值
*p1 = *p1 ^ *p2; // 再次异或，恢复 b 的原始值

// 现在 a 和 b 的值已经交换
```

这种方法利用了异或运算符（`^`）的性质，通过异或可以无损地交换两个数的值。但是，这种方法要求两个变量的类型和大小完全相同，并且它们的地址不重叠。

注意事项

- 当交换的是复杂类型（如结构体、类对象等）时，上述方法可能不适用，因为它们可能包含指针或动态分配的内存，这时需要使用特定的交换函数或操作。
- 在使用指针方法时，务必确保两个指针指向不同的内存地址，否则会导致数据丢失。
- 对于非数值类型或大型数值，可能需要考虑使用标准库中的 `std::swap` 函数或其他适当的方法来避免溢出和确保数据安全。



在实际编程中，推荐使用 `std::swap` 函数来交换两个变量的值，因为它简单、安全且易于理解：

```cpp
#include <algorithm> // 对于 C++

int a = 5;
int b = 10;

std::swap(a, b); // 交换 a 和 b 的值
```

`std::swap` 函数是标准库提供的，它会根据变量的类型选择合适的交换方法，从而避免潜在的问题。





## strcpy 和memcpy 的区别

## 执行 `int main(int argc, char *argv[])` 时的内存结构

## volatile 关键字的作用？

`volatile` 是 C 和 C++ 等编程语言中的一个关键字，用于告诉编译器一个变量可能会被未知因素（如硬件、操作系统、中断服务例程或其他线程）意外地改变，因此编译器在访问这个变量时不应该对其进行优化，每次需要读取或写入时都应该直接从内存中进行，而不是使用寄存器或缓存中的值。

`volatile` 关键字的主要作用包括：

1. **防止编译器优化**：编译器在优化代码时可能会重排指令、缓存变量值或省略对变量的读写操作，以提高性能。对于标记为 `volatile` 的变量，编译器必须每次在需要时都从内存中读取或写入变量的值，即使这看起来没有意义。
2. **确保内存访问的及时性**：在多线程环境中，一个线程对 `volatile` 变量的写操作对其他线程立即可见。这有助于确保所有线程看到的变量值是最新的。
3. **硬件或外部事件驱动的变量**：在嵌入式系统或驱动程序开发中，`volatile` 变量常用于表示由硬件或外部事件（如按键、传感器读数、信号等）更新的变量。
4. **防止指令重排**：在某些情况下，`volatile` 变量的读写操作可以作为内存屏障，防止编译器对指令进行重排，确保关键操作的执行顺序。





## 讲讲大端小端，如何检测（三种方法）

大端（Big-Endian）和小端（Little-Endian）是计算机系统中表示多字节数据中字节顺序的术语。在大端模式中，最高有效字节（MSB）存储在最低的内存地址，其余字节按顺序存储；在小端模式中，最低有效字节（LSB）存储在最低的内存地址，其余字节按相反顺序存储。

大端模式（Big-Endian）:

```
例如，32位整数 0x12345678 在内存中的存储方式：
内存地址    数据
0x00        0x12
0x01        0x34
0x02        0x56
0x03        0x78
```

小端模式（Little-Endian）:

```
同样的32位整数 0x12345678 在内存中的存储方式：
内存地址    数据
0x00        0x78
0x01        0x56
0x02        0x34
0x03        0x12
```

检测系统字节序的方法：

1. **编写特定的C/C++程序**:
   下面是一个使用C语言编写的程序，用于检测系统的字节序：

   ```c
   #include <stdio.h>
   
   int main() {
       unsigned int x = 0x12345678;
       char *c = (char*)&x;
   
       if (*c == 0x78) {
           printf("小端模式\n");
       } else {
           printf("大端模式\n");
       }
   
       return 0;
   }
   ```
   这段代码通过将一个整数的地址转换为`char`指针，然后检查该整数的第一个字节。如果第一个字节是最低有效字节（`0x78`），则系统是小端模式；否则，系统是大端模式。

2. **使用网络字节序**:
   网络字节序是大端模式，所有网络通信都使用这种字节序。如果你需要将一个值转换为网络字节序，可以使用`htonl`函数（对于主机到网络的转换），然后检查结果。例如，在C语言中：

   ```c
   #include <arpa/inet.h>
   #include <stdio.h>
   
   int main() {
       unsigned int x = 0x12345678;
       unsigned int net_order = htonl(x);
   
       if (*(char*)&net_order == 0x12) {
           printf("大端模式\n");
       } else {
           printf("小端模式\n");
       }
   
       return 0;
   }
   ```
   这段代码通过`htonl`函数将一个整数转换为网络字节序，然后检查转换后的整数的第一个字节。如果第一个字节是最高有效字节（`0x12`），则系统是大端模式；否则，系统是小端模式。

3. **使用特定指令**:
   在某些编程语言或架构中，可能有特定的指令或函数来检测字节序。例如，在C语言中，可以使用预处理器指令来检测：

   ```c
   #include <stdio.h>
   
   #define IS_BIG_ENDIAN (*(char*)&int{1} == 1)
   
   int main() {
       if (IS_BIG_ENDIAN) {
           printf("大端模式\n");
       } else {
           printf("小端模式\n");
       }
   
       return 0;
   }
   ```
   这段代码通过定义一个`int`类型的变量，并检查其第一个字节是否为`1`。如果为`1`，则系统是大端模式；否则，系统是小端模式。

这些方法可以帮助你检测你的系统是大端模式还是小端模式。了解系统的字节序对于处理跨平台数据交换和网络通信非常重要，因为你必须确保数据在不同的系统之间以相同的方式被解释。





## 查看内存的方法

在编程中，查看内存内容通常涉及到调试和分析程序的行为。以下是一些常用的方法和工具，可以帮助你查看和分析程序中的内存状态：

1. 调试器

调试器是查看内存内容的强大工具。大多数开发环境都提供了调试器，例如：

- **GDB**（GNU Debugger）：用于Linux和Unix系统的命令行调试器。
- **Visual Studio Debugger**：Windows系统上的集成调试环境。
- **lldb**：LLVM项目的一部分，用于macOS和Linux的调试器。

使用调试器，你可以：

- 设置断点来暂停程序执行。
- 检查和修改变量的值。
- 逐行执行代码以观察内存变化。
- 查看调用栈和寄存器状态。

2. 内存分析工具

内存分析工具可以帮助你识别内存泄漏和其他内存相关问题。一些流行的内存分析工具包括：

- **Valgrind**：一个分析Linux程序内存使用的工具，可以检测内存泄漏、内存损坏等问题。
- **LeakSanitizer**：一个快速的内存泄漏检测器，可以集成到GCC和Clang编译器中。
- **Dr. Memory**：一个内存和线程错误检测工具，适用于Windows、Linux和macOS。

3. 操作系统工具

操作系统提供了一些内置工具来查看系统内存使用情况：

- **Windows**：
  - **任务管理器**：可以查看进程的内存使用情况。
  - **Resource Monitor**：提供更详细的内存使用情况和性能计数器。
- **Linux**：
  - **top**：实时显示系统的进程和资源使用情况。
  - **htop**：一个增强版的top工具，提供更丰富的信息和更好的用户界面。
  - **/proc/meminfo**：一个文件，包含了系统内存的使用信息。

4. 编程接口

一些编程语言提供了API来查询内存使用情况。例如，在C++中，你可以使用`malloc`和`free`函数来手动管理内存，并使用`mallinfo`（在某些系统上可用）来获取内存分配器的统计信息。

5. 代码审查和静态分析

虽然不是直接查看内存，但通过代码审查和静态分析工具可以帮助识别可能导致内存问题的代码模式，如未初始化的变量、错误的内存访问等。





## 空类会默认添加哪些东西？怎么写？

在C++中，一个被定义为“空”的类，即使不显式地添加任何成员或方法，也会隐式地包含一些默认的东西。这些默认内容主要是为了支持类的实例化和基本的类行为。以下是空类会默认添加的内容：

1. **默认构造函数**：
   如果用户没有为类定义任何构造函数，编译器会为该类生成一个默认的无参数构造函数。这个构造函数不执行任何操作，只是简单地初始化类的对象。

   ```cpp
   class EmptyClass {
   }; // 空类
   
   // 等价于用户定义了以下构造函数：
   EmptyClass() {} // 默认构造函数
   ```

2. **默认析构函数**：
   如果类没有定义析构函数，编译器会生成一个默认的析构函数。这个析构函数同样不执行任何操作，只是负责销毁对象。

   ```cpp
   ~EmptyClass() {} // 默认析构函数，通常不显示
   ```

3. **默认拷贝构造函数**：
   如果类没有定义拷贝构造函数，编译器会生成一个默认的拷贝构造函数，用于创建一个对象的副本。

   ```cpp
   EmptyClass(const EmptyClass&) {} // 默认拷贝构造函数，通常不显示
   ```

4. **默认拷贝赋值操作符**：
   如果没有为类定义拷贝赋值操作符，编译器会提供一个默认的实现，用于将一个对象的内容复制到另一个对象。

   ```cpp
   EmptyClass& operator=(const EmptyClass&) { return *this; } // 默认拷贝赋值操作符，通常不显示
   ```

5. **默认移动构造函数**：
   C++11及更高版本中，如果没有定义移动构造函数，编译器会生成一个默认的移动构造函数。

   ```cpp
   EmptyClass(EmptyClass&&) noexcept {} // 默认移动构造函数，通常不显示
   ```

6. **默认移动赋值操作符**：
   同样地，如果没有定义移动赋值操作符，编译器也会提供一个默认的实现。

   ```cpp
   EmptyClass& operator=(EmptyClass&&) noexcept { return *this; } // 默认移动赋值操作符，通常不显示
   ```

7. **虚函数表（如果类被继承）**：
   如果空类是从基类继承的，即使没有定义任何成员函数，编译器也会为该类添加一个虚函数表，以便支持多态。

   ```cpp
   struct Base {
       virtual void dummy() {} // 基类的虚函数
   };
   
   struct Derived : public Base {
   }; // 空派生类，但包含虚函数表
   
   // Derived 对象将包含 Base 类的虚函数表
   ```

8. **类的类型信息**：
   编译器会为每个类生成类型信息，例如用于 `typeid` 操作符的类型标识。

以上是空类在C++中默认添加的内容。这些默认的成员和行为使得空类可以被实例化和基本操作，而不需要用户显式定义。然而，如果需要自定义类的行为，比如管理资源或实现特定的接口，就需要显式地定义构造函数、析构函数和其他成员函数。





## 标准库是什么？

## const char*与 string之间的关系，传递参数问题？

`const char*` 和 `std::string` 的区别

1. **内存管理**：
   - `const char*` 是一个指向字符数组的指针，通常指向一个以空字符（`\0`）结尾的字符串。它不负责管理内存，因此指向的字符串可能是静态存储的，或者是动态分配的内存，需要手动管理其生命周期。
   - `std::string` 是一个封装了字符数组的类，它负责管理内存的分配和释放。`std::string` 提供了许多成员函数，用于字符串操作，如追加、插入、查找等。
2. **可变性**：
   - `const char*` 指向的字符串是不可变的，因为它指向的数据通常不应该被修改。如果需要修改字符串，必须创建一个新的字符串副本。
   - `std::string` 对象是可变的，可以安全地修改字符串内容，而不需要担心内存泄漏或其他低级错误。
3. **安全性**：
   - 使用 `const char*` 时，需要确保不会意外修改指向的数据，并且要正确处理指向的内存的生命周期。
   - 使用 `std::string` 时，不需要担心这些问题，因为 `std::string` 会自动处理内存管理。



传递参数问题

在C++中，函数参数可以是 `const char*` 或 `std::string` 类型，选择哪种类型取决于函数的需求和设计意图。

1. **传递 `const char\*`**：
   - 当函数只需要读取字符串内容，而不需要修改它时，使用 `const char*` 可能更合适。这可以提高性能，因为 `const char*` 是一个指向现有数据的指针，不需要复制整个字符串。
   - 如果函数需要处理大量字符串数据，或者需要频繁地修改字符串，使用 `const char*` 可能会导致不必要的数据复制。
2. **传递 `std::string`**：
   - 当函数需要修改字符串或者需要安全地处理字符串时，使用 `std::string` 更合适。`std::string` 提供了丰富的成员函数，可以方便地进行字符串操作。
   - 如果函数需要保持与C语言的兼容性，或者需要与标准库中的其他函数交互，使用 `const char*` 可能更合适，因为标准库中的许多字符串操作函数都接受 `const char*` 类型的参数。





## new, delete, operator new, operator delete, placement new, placement delete

operator new和placement new都是C++中用于动态内存分配的操作符。

* operator new是C++标准库中的函数，它会在堆上分配一块指定大小的内存，并返回指向该内存块的指针。它可以被重载以实现自定义的内存管理策略，但不能控制对象的构造和析构过程。
* placement new是一个特殊的语法，它可以在已分配的内存块上构造对象。它不会分配内存，而是将对象放置在指定的内存地址上。





## 为什么拷贝构造函数必须传引用不能传值？

拷贝构造函数的作用是用一个已存在的对象来初始化一个新的对象。如果拷贝构造函数的参数是传值的话，那么会发生对象的复制，这样会浪费时间和内存资源。而如果传递的是引用，只是传递了指向对象的地址，这样可以避免对象的复制，提高程序的效率。
此外，如果传递的是引用，还可以避免拷贝构造函数的无限递归调用。因为如果传递的是值，那么会调用拷贝构造函数来初始化参效，而初始化参数又需要调用拷贝构造函数，这样就会无限递归调用拷贝构造函数，导致程序崩溃。而传递引用则可以避免这种情况的发生。





## 空类的大小是多少？为什么？

一个空的C++类在不同的编译器和操作系統上的大小可能会有所不同，但是通常情况下，空的类的大小为1字节。这是因为C++规定每个对象都必须占据至少一个字节的内存空间，以便于对它们进行地址计算和内存对齐等操作。即使一个类没有任何成员变量，它也必须有一个非零的大小。





## 你什么情况用指针当参数，什么时候用引用，为什么？

在C++中，使用指针或引用作为函数参数都可以实现传递参数的目的，但它们在使用时有一些不同的规则和约束。一般来说，使用指针或引用作为函数参数的情况如下

使用指针作为函数参数的情况：

1.   当函数需要修改传入的参数的值时，可以使用指针作为参数。因为指针可以直接访问参数的地址，可以通过指针来修改参效的值。
2.   当函数需要传递一个指向数组的指针时，可以使用指针作为参数。因为数组名本身就是一个指针，可以直接传递。
3.   当函数需要返回多个值时，可以使用指针作为参数。因为指针可以指向多个变量，可以通过指针来返回多个值。
使用引用作为函数参数的情况：
1.   当函数需要修改传入的参数的值时，可以使用引用作为参效。因为引用可以直接访问参数的地址，可以通过引用来修改参效的值。
2.   当函数需要传递一个对象时，可以使用引用作为参数。因为引用可以避免对象的拷贝，可以提高程序的效率。
3. 当函数需要返回一个值时，可以使用引用作为参数。因为引用可以直接指向一个变量，可以通过引用来返回一个值。
引用提供了更强的类型检查，并且不能为空。
如果函数能接受nullptr指针，可以使用指针。





## 大内存申请时候选用哪种？C++变量存在哪？变量的大小存在哪？符号表存在哪？

在C++中，大内存申请时可以使用以下两种方式：

1.   使用new/delete运算符进行动态内存分配，这种方式可以在堆上分配内存，可以申请较大的内存空间。
2.   使用malloc/free函数进行动态内存分配，这种方式可以在堆上分配内存，可以申请较大的内存窒回。
     在C++中，变量的存储位置取决于其作用域和存储类型。全局变量和静态变量存储在静态存储区中，局部变量和动态分配的变量存储在堆或栈中。

变量的大小可以通过sizeof运算符获取，这个大小包括变量的类型及其所占用的空间大小。

符号表存储在编译器生成的可执行文件中，用于记录程序中的符号信息，例如变量名、函数名等。符号表中记录了这些符号的类型、作用域、存储位置等信息，编译器在编译时使用符号表进行符号解析。





## 为什么会有大端小端，htol 这一类函数的作用

大小端是指计算机系统中数据的存储顺序，即数据的高位部分和低位部分存储的顺序。

* 大端字节序是指低位字节存放在高地址中，高位字节存放在低地址中，即高位字节先发送，低位字节后发送
* 小端字节序是指低位字节存放在低地址中，高位字节存放在高地址中，即低位字节先发送，高位字节后发送。
htol这类函数的作用是将主机字节序转换为网络字节序，也就是将小端字节序转换为大端字节序。

总的来说，大小端是因为计算机系统的历史和发展原因，而htol作用是为了数据的正确传输和存储





## 静态函数能定义为虚函数吗？常函数？

静态函数不能定义为虚函数，因为虚函数是通过对象的虚函数表来调用的，而静态函数不属于任何对象，无法使用虚函数表来调用。

静态函数可以被定义为常函数。常函数是指在函数体中不改变任何变量的值，并且不返回任何值的函数。静态函数和常函数的主要区别在于它们的作用域和链接性。静态函数的作用域只限于所在的文件，而常幽数的作用域可以是整个程序。静态函数可以被链接到程序的多个位置，而常函数只能被链接到程序的单个位置。因此，静态函数更适合被定义为常函数，因为它不需要在多个位置被链接，并且它的作用域只限于它所在的文件。





## this 指针调用成员变量时，堆栈会发生什么变化？

当使用 this 指针调用成员变量时，堆栈会发生以下变化：

1. this指针会被压入堆栈，指向当前对象的地址。
2. 根据 this 指针的地址，找到对应的对象，并访问其成员变量。
3. 当函数返回时，this 指针会被弹出堆栈，恢复原来的上下文环境。

需要注意的是，this指针的地址是在函数调用时被压入堆栈的，因此在函数内部使用this 指针时，需要先使用点运算符获取 this 指针的地址，然后再访问成员变量。

在调用成员变量时，编译器会使用this指针来访问对象的成员变量，而不会在堆栈上创建新的变量。因此，使用this指针调用成员变量不会对堆栈造成任何影响。





## 静态绑定和动态绑定的介绍

* 静态绑定是指在编译时确定函数的调用地址，也就是在编译时就已经确定了函数的调用方式。静态绑定通常使用函数名和参数关型来确定函数的地址。静态綁定适用于普通函数和类的非虚函数。
* 动态绑定是指在运行时确定函数的调用地址，也就是在程序运行时才会确定函数的调用方式。动态绑定通常使用虚函数来实现，因为虚函数允许子类重写父类的函数。当使用动态绑定时，编译器会在运行时根据实际对象类型调用相应的函数。
  总的来说，静态绑定适用于普通函数和类的非虚函数，而动态绑定适用于类的虚函数。静态绑定的效率更高，但是灵活性较差；动态绑定的效率较低，但是具有更茼的灵活性。





## 设计一个类计算子类的个数





## 怎么快速定位错误出现的地方

在C++编程中，快速定位错误出现的地方是调试过程中的一个重要技能。以下是一些常用的方法和技巧，可以帮助你更高效地定位和解决C++代码中的错误：

1. **使用编译器的警告和错误信息**：
   - 仔细阅读编译器输出的警告和错误信息，它们通常会指出问题发生的位置和可能的原因。
   - 使用高级编译器选项（如GCC的`-Wall`或Clang的`-Weverything`）来获取更多的警告信息。

2. **使用调试器**：
   - 使用GDB、LLDB或其他调试器运行程序，它们可以在代码中设置断点、单步执行、查看变量状态等。
   - 利用调试器的“backtrace”或“where”命令来查看函数调用栈，这有助于找到错误发生的上下文。

3. **核心转储和分析**：
   - 如果程序崩溃，可以尝试生成核心转储文件，并使用调试器分析这些文件来确定崩溃的原因。

4. **单元测试和自动化测试**：
   - 编写单元测试可以帮助你验证代码的每个部分是否按预期工作。
   - 使用持续集成（CI）系统来自动运行测试，可以在代码变更后及时发现引入的错误。

5. **代码审查**：
   - 通过代码审查，让其他开发者检查你的代码，他们可能会发现你没有注意到的问题。

6. **日志记录**：
   - 在代码中添加日志记录语句，特别是在关键操作和可能出错的地方，这可以帮助你追踪程序的执行流程和状态。

7. **静态代码分析工具**：
   - 使用静态代码分析工具（如Cppcheck、Clang Static Analyzer）来检查代码中潜在的错误和不良编码实践。

8. **断言和运行时检查**：
   - 使用断言（`assert`）来检查代码中的假设条件是否满足，这可以在早期发现潜在的问题。

9. **二分查找法**：
   - 如果错误难以定位，可以尝试二分查找法，即逐步注释掉代码的一半，然后编译和测试，以此来缩小问题范围。

10. **IDE和编辑器功能**：
    - 利用集成开发环境（IDE）和代码编辑器的智能提示、代码导航和错误高亮功能来辅助定位问题。

11. **在线资源和社区**：
    - 当你遇到特定的编译错误或运行时问题时，可以搜索在线资源（如Stack Overflow）或向编程社区求助。

记住，调试是一个逐步排除问题的过程，有时需要耐心和细致的分析。通过结合上述方法，你可以更快地定位和解决C++代码中的错误。





## 虚函数的代价？

虚函数的代价主要体现在两个方面

* 运行时开销：虚函数的调用需要在运行时进行动态绑定，这会导致额外的开销，包括查找虚函数表、确定正确的函数地址
* 内存占用：每个包含虚函数的类都需要维护一个虚函数表，这会占用额外的内存空间。

因此，在需要高性能的场景下，虚函数的代价可能会成为一个问题。在这种情况下，可以考虑使用其他的技术来实现多态性，例如模板、函数指针等。但是，在需要灵活性和可扩展性的场景下，虚函数仍然是一种非常有用的技术。





## 类对象的大小

空对象：1

虚函数：8

有虚函数的类和无虚函数的类的大小有所不同。

* 对于无虚函数的类，它的大小就是其成员变量的大小之和，不包括任何内存对齐的空间。
* 对于有虚函数的类，除了其成员变量之外，还需要为虚函数表（vtable）分配内存空间。虚函数表是一个指向虚函数地址的指针数组，用于实现动态绑定。因此，有虚函数的类的大小会比无虚函数的类的大小大一些，具体增加的大小取决于虛函效表的大小。

此外，还需要注意的一点是，由于内存对齐的原因，有时候即使是没有虚函数的类，其大小也可能会比其成员变量的大小之和要大一些。这是因为编译器为了对齐内存而在类的成员变量之间填充了一些空间。





## 移动构造函数

## 何时需要合成构造函数

合成构造函数（synthesized constructor）是在C++中由编译器自动生成的构造函数。当一个类没有显式定义任何构造函数时，编译器会提供一个默认的合成构造函数，这个构造函数会调用基类的默认构造函数（或指定的基类构造函数），并对成员变量进行默认初始化（或直接初始化）。





## 何时需要合成复制构造函数



## 何时需要成员初始化列表？过程是什么？

成员初始化列表是C++中类构造函数中的一个特性，它允许在构造函数体执行之前初始化类的成员变量。成员初始化列表在构造函数的参数列表之后，以冒号（:）开始，后跟成员变量和它们的初始值。使用成员初始化列表有几个重要的场景和好处：

何时需要成员初始化列表：

1. **初始化常量成员**：对于常量成员变量，必须在类构造函数之前初始化，因为常量成员在使用前必须已经被初始化。

   ```cpp
   class MyClass {
   public:
       const int value;
       MyClass(int v) : value(v) {}
   };
   ```

2. **初始化引用成员**：引用成员必须在构造时被初始化，因为引用一旦被创建就不能被重新赋值。

   ```cpp
   class MyClass {
   public:
       int& ref;
       MyClass(int& r) : ref(r) {}
   };
   ```

3. **初始化继承的成员**：当派生类从基类继承成员时，使用成员初始化列表可以确保基类的构造函数被正确调用，从而初始化继承的成员。

   ```cpp
   baseClass b;
   derivedClass d(b);  // 基类的构造函数通过成员初始化列表被调用
   ```

4. **提高性能**：对于大型对象或者需要频繁创建和销毁的对象，使用成员初始化列表可以避免不必要的对象复制或赋值操作，从而提高性能。

   ```cpp
   class MyClass {
   public:
       std::vector<int> vec;
       MyClass(int size) : vec(size) {} // 直接初始化，避免vec.resize(size)的开销
   };
   ```

5. **初始化复杂类型成员**：对于复杂类型（如STL容器、其他对象等），使用成员初始化列表可以利用复杂类型的默认构造函数、拷贝构造函数或移动构造函数。

   ```cpp
   class MyClass {
   public:
       std::map<int, std::string> map;
       MyClass() : map({{1, "one"}, {2, "two"}}) {} // 使用列表初始化
   };
   ```



成员初始化列表的过程：

1. **构造函数参数**：首先，成员变量通过成员初始化列表进行初始化。这些初始化操作是在构造函数参数被处理之后进行的。

2. **按照成员变量在类中的声明顺序**：成员变量的初始化顺序是它们在类定义中出现的顺序，而不是它们在成员初始化列表中的顺序。

3. **基类初始化**：如果成员初始化列表中包含了基类的初始化（使用冒号`:`），则基类的构造函数会在派生类的构造函数体执行之前被调用。

4. **构造函数体**：一旦所有成员变量都初始化完成，构造函数体就会执行。在构造函数体中，可以进行更复杂的初始化或执行其他必要的操作。

使用成员初始化列表是C++中的一种最佳实践，它可以提高代码的效率、清晰度和安全性。正确使用成员初始化列表有助于避免潜在的错误，并确保对象的状态在构造过程中保持一致。





## 程序员定义的析构函数被扩展的过程？

C++中的析构函数是用于释放对象占用的资源，销毁对象的过程。当对象被销毁时，析构函数会自动调用，执行一些清理工作。析构函数的扩展过程如下：

1. 调用析构函数：当对象被销毁时，编译器会自动调用析构函数。如果对象是通过new运算符动态分配的，那么必须使用delete运算符显式地销毁对象，否则析构函数不会被调用。

2. 执行析构函数代码：当析构函数被调用时，它会执行一些清理工作。例如，释放对象占用的内存、关闭文件句柄等。
3. 调用基类的析构函数：如果对象是派生类对象，那么在销毁对象之前，必须先调用基类的析构函数。是因为派生类对象中包合了基类对象的成员变量，这些成员变量也需要被销毁。
4. 调用成员变量的析构函数：如果对象包含成员变量，那么在销毁对象之前，必须先调用这些成员变量的析构函数。这是因为成员变量可能包含指针，需要释放内存。
5. 销毁对象：当析构函数执行完毕后，对象会被销毁。此时，对象占用的内存会被释放，对象的生命周期也随之结束。
    总之，析构函数的扩展过程包括调用析构函数、执行析构函数代码、调用基类的析构函数、调用成员变量的析构函数和销毁对象。这个过程确保了对象被正确地销毁，避免了内存泄漏和资源浪费。






## 构造函数的执行算法？

C++构造函数的执行算法如下：

1. 分配内存空间：在对象创建之前，先分配内存空间，包括对象的数据成员和虚函数表等。

2. 初始化成员变量：在分配内存空间后，对对象的所有成员变量进行初始化，包括基本类型、指针类型、引用类型和类类型等
3. 执行构造函数体：在成员变量初始化完成后，执行构造函数体内的语句，完成对象的初始化工作。
4. 返回对象地址：构造函数执行完毕后，返回对象的地址，可以通过该地址访问对象的成员变量和成员函数。
   需要注意的是，C++构造函数的执行顺序是按照成员变量的声明顺序进行的，而不是按照初始化列表的顺序。因此，在编写构造函数时，应该按照成员变量的依赖关系和初始化顺序进行初始化，避免出现未定义行为。






## 构造函数的扩展过程？

构造函数的扩展过程包括以下步骤：

* 分配内存：首先，系统会为新对象分配内存。
* 初始化基类：如果新对象是一个派生类的对象，那么系统会先初始化它的
* 调用构造函数：然后，系统会调用构造函数来初始化新对象。
* 返回指向新对象的指针：最后，系统会返回一个指向新对象的指针。

总的来说，构造函数的扩展过包括分配内存、初始化基类，调用构造函数和区回指向新对象的指针。





## sizeof 和 strlen 的区别

## 简述 strcpy、sprintf 与 memcpy 的区别

## 编码实现某一变量某位清0或置1



## 将"引用"作为函数参数有哪些特点？

## 分别写出 bool/int/float/指针类型的变量a与“零”的比较语句。

## 局部变量全局变量的问题？

## 数组和指针的区别？

## C++如何阻止一个类被实例化？一般在什么时候将构造函数声明为private?

要阻止一个类被实例化，可以将其无参构造函数声明为私有。这样，只有该类的友元或成员函数才能创建该类的实例。

拷贝构造函数声明为private通常用于实现单例模式。在单例模式中，只允许创建一个类的实例。因此，将拷贝构造函数声明为私有可以防止通过复制构造函数创建多个实例。



## 如何禁止自动生成拷贝构造函数？

## 声明一个私有的拷贝构造函数

## assert 与NDEBUGE

## Debug 和 release 的区别

## main 函数有没有返回值

## 写一个比较大小的模板函数



## c++怎么实现一个函数先于 main 函数运行

在 C++中，我们可以使用全局对象和静态成员函数来实现一个函教先于main运行。

* 全局对象：我们可以在全局范围内定义一个对象，然后在该对象的构造函数中调用我们需要的函救，全局对象的构造函数会在main函数之前执行。
* 静态成员函数：我们可以在类中定义一个静态成员函数，然后在main函数中调用这个函数，静态成员函数是属于类的，不属于任何对象，因此它的生命周期不受对象的影响





## 智能指针怎么用？智能指针出现循环引用怎么解决？

智能指针是一种特殊的指针，它可以自动管理内存，避免内存泄漏。

智能指针的主要类型包括`unique_ptr`、`shared_ptr`和`weak_ptr`

* `unique_ptr `：表示唯一拥有某个对象的指针。当`unique_ptr`对象被销毁时，它所指向的对象也会被销毁
* `shared_ptr`：表示多个对象共享某个对象的指针。当所有的`shared_ptr`对象都被销毁时，它所指向的对象也会被销毁。
* `weak_ptr`：表示一个弱引用，它不会加被引用对象的引用计数。当被引用对象被销毁时，`weak_ptr`对象会变为空。

使用智能指针
* 创建智能指针对象：可以使用`make_shared`、`new`等方法创建智能指针对象
* 使用智能指针：可以像使用普通指针一样使用智能指针，智能指针会自动管理内存。

避免出循环引用
* 在多个对象之间存在循环引用时，可以使用`weak_ptr`来打破循环
* 使用`std::enable_shared_from_this`：`std::enable_shared_from_this`是一个模板类，它可以让一个对象知道自己被哪个`std::shared_ptr`所管理。可以使用`std::enable_shared_from_this`来避免循环引用






## strcpy 函效和strncpy函数的区别？哪个函数更安全？

`strcpy`函数

`strcpy`函数原型如下：

```
char *strcpy(char *dest, const char *src);
```

`strcpy`函数用于将`src`指向的字符串复制到`dest`指向的位置，包括结束的空字符（`\0`）。它会一直复制直到遇到`src`中的字符串结束符`\0`。`dest`的大小必须足够大，以便能够存放`src`的内容，包括结尾的`\0`。

**问题**：如果`dest`的内存空间不足以存放`src`的内容，`strcpy`会导致缓冲区溢出，这是常见的安全漏洞之一，可能被用来执行恶意代码。



`strncpy`函数

`strncpy`函数原型如下：

```
char *strncpy(char *dest, const char *src, size_t n);
```

`strncpy`函数与`strcpy`类似，但它在复制时会考虑`dest`的大小。它会复制`n`个字节的数据从`src`到`dest`，如果`src`的长度小于`n`，剩余的部分会用空字符填充。如果`src`的长度大于或等于`n`，则不会在`dest`中添加字符串结束符`\0`。

**问题**：如果`src`的长度大于或等于`n`，`strncpy`不会在`dest`中放置字符串结束符`\0`，这可能导致在使用`dest`作为C风格字符串时出现未定义行为，因为C风格字符串必须以`\0`结尾。



安全性比较

`strncpy`通常被认为比`strcpy`更安全，因为它避免了缓冲区溢出的风险。然而，`strncpy`也有其自身的问题，特别是在没有正确处理字符串结束符的情况下。为了确保安全，使用`strncpy`时必须确保以下几点：

1. 知道`dest`需要的确切大小，并确保`n`参数正确反映了这一点。
2. 在`dest`中手动添加字符串结束符`\0`，以确保它是一个有效的C风格字符串。





## 为什么要用 static_cast 转换而不用c语言中的转换？

使用static_cast不是C语言的转换，是因为static_cast提供了更加安全和可读的类型转换方式。C语言的转换是强制类型转换，它会直接将一个类型转换成另一个类型，而不考虑类型之间的兼容性和安全性。这种转换容易引起不必要的错误和问题。

相比之下，static_cast提供了一种更加安全的类型转换方式，它会在编译时检直类型之间的兼容性，如果不兼容则会报错，从而避免了潜在的运行时错误。此外，static_cast可以提高代码的可读性，因为已明确地指明了类型转换的目的和方式，使代码更易于理解和维护。因此，在C++中，推荐使用static_cast进行类型转换。





## 成员函数里 `memset(this, 0, sizeof(*this))`会发生什么

成员函数调用`memset(this, 0, sizeof(*this))`会将当前对象所占用的内存空间全部清零。

具体来说，这个函数会将当前对象的内存空间的前`sizeof(*this`)个字节全部设置为0。因为this指针指向当前对象，所以`memset`会将当前对象的内存空间全部清零。

这个操作通常用于初始化对象的内存空间，以确保对象的状态是可预测的。例如，如果一个对象包含一些成员变量，这些成员变量的初始值对于对象的正确使用非常重要，那么可以在对象的构造函数中调用`memset`函数来初始化对象的内存空间，以确保这些成员变量被正确初始化。





## 方法调用的原理（栈，汇编）

方法调用是编程中的一个基本操作，它涉及到内存管理，栈操作和汇编语言。

在C++中，当我们调用一个方法时，会发生以下步骤：

* 保存调用方法的上下文：在调用方法之前，会将一些信息保存到栈中，包括返回地址、参数等。这个过通常由编译器自动完成。
* 传递参数：如果方法有参数，会将参数的值复制到栈中，这个过程也是由编译器自动完成的。
* 跳到方法的地址：在调用方法时，会将程序的执行流转到方法的地址。这个过程通常由编译器自动完成。
* 执行方法：在方法的地址处，执行方法的代码，这个过程由方法的实现决定。
* 返回：在方法执行完成后，会这回到调用方法的地方，继续执行后续的代码。这个过程通常由编泽器自动完成，
  在汇编语言中，方法调用的过程可能会更加复杂，例如，如果方法是虚函数，那么在调用方法时，需要先获取对象的虚表，然后根据虚表中的信息找到方法的地址。

这些步骤通过汇编指令来实现，例如将返回地址保存在栈中使用的是PUSH指令，将参数压入栈中使用的是MOV指令，跳转到被调用方法的入口地址使用的是CALL指令，将返回值压入栈中使用的是MOV指令，恢复调用方方法的现场使用的是RET指令等。





## MFC 消息处理如何封装的？





## 回调函数的作用

回调函数是一种特珠的函数，它不是由程序员直接调用的，而是在某些特定的情况下由系统或其他函数调用。

回调函数的作用主要有以下几点

* 异步处理：回调函数可以用于异步处理，即在某个操作完成后，系统或某他函数会调用回调函数来处理结果。
* 事件处理：回调函数可以用于处理各种事件，如按键事件、鼠标事件等。
* 自定义函数：回调函数可以用于自定义函数，即在某个函数中定义一个回调函数，然后在其他地方调用这个回调函数。
在C++中，我们可以使用函数指针作为回调函数。例，我们可以定义一个函数指针类型，然后在函数中接收这个函数指针，然后在需要的时候调用这个函数。
