# GCC

## 概述

### 介绍

* 全称为GNU Compiler Collection。
*  最初只是一个C语言编译器，是GNU C Compiler 的英文缩写。
*   随着众多自由开发者的加入和GCC自身的发展，如今GCC可以编译的语言包括：C、C++、Objective-C、Fortran、Java、Ada
    * 在特指C++编译时，该编译器常被称为“G++”。
* 可从https://gcc.gnu.org下载
*   GCC版本使用`gcc -v`查看



### 用法示例

* 假设除标准头文件、本目录文件外不引用其他头文件，加上各种编译选项用法相同
*   有三个文件a.c b.c test.c，如何生成程序test？最简单的只需要这样
    * `gcc a.c b.c test.c -o test`
* 逻辑有错误，gdb调试看不到源码？加上-g选项再试试gdb test
    * `gcc a.c b.c test.c -g -o test`
* 为什么我生成的test程序比其他人生成的慢？试试优化选项-O2
    * `gcc a.c b.c testc -g -O2-o test`
* 这个地方怎么总提示编译错误，代码也没问题？预编译看看代码到底是什么？
    * `gcc -E a.c > a.i` 预编译后你可以看到真正要编译的代码
* 怎样只编译一个c文件，这个c文件的汇编是什么样的？
    *   `gcc -c a.c -o a.o`
    *   `gcc -S a.c -o a.s`
*   汇编可以带源码么？这样组合使用
    * `gcc -c -g a.c -o a.o`注意要加上-g选项
    * `objdump -S a.o > a.txt`看源码和汇编



### 文件后缀约定

* 一般大家都按照下面的约定命名文件后缀名。如果你们没有遵守，没关系。通过-x选项指定也可以，如`gcc -x c++`编译指定的语言如c++，`gcc -x c`指定c语言，`gcc -x none`相当于不使用`-x`选项。
*  .c文件，C语言源代码文件；
*  .a文件，是由目标文件构成的档案库文件，使用ar程序生成；
*  .C、.cc、.cpp或.cxx 文件，是C++源代码文件，使用g++编译；
*  .h文件，是程序所包含的头文件；
* .i文件，是已经预处理过的C源代码文件；
* .ii文件，是已经预处理过的C++源代码文件；
*  .o文件，是编译后的目标文件，使用gcc -c选项生成；
*  .s文件，是汇编语言源代码文件；
*  .S文件，是经过预编译的汇编语言源代码文件。



### 二进制工具集

http://www.gnu.org/software/binutils/

* `as`：gnu 汇编工具
*   `ld`：gnu 链接器
*   `addr2line` ：将地址转换成文件名和行号
*   `ar`：gnu 档案库文件生成工具
*   `objcopy`：将目标文件翻译或复制成另一种格式或去除符号表、调试段等信息
*   `objdump`：显示目标文件的各种信息
    *   `-d`：显示反汇编
    *  `-D`：显示反汇编和全局变量等
    *   `-S`：显示源码与汇编（编译时需要`-g`选项）
* `nm`：列举目标文件中的符号信息，如-u查看未定义符号
*   `strip`：去除符号表
*   `readelf`：分析elf并显示信息
*   `gprof`：性能分析工具
*   `gcov`：代码覆盖统计



### 编译错误

GCC编译错误输出包括行号和错误信息，大部分错误找到行号很容易修改：

*  如变量未定义、笔误拼错单词、条件语句括号不匹配、重复定义等
*  中文标点或空格之类的提示`error: stray '\241' in program`
* 如果是编译宏不匹配，提示较为明确，没有`#endif`或者没有`#if`
*  略微复杂些的譬如大括号不匹配，如expected declaration之类的错误提示，这个时候一般检查大括号匹配



如果遇到了百思不解的错误，请尝试

*  预编译 `gcc -E a.c > a.i` 如果还不能找到错误，请继续；
*  一般这个时候就得试试缩小范围了，先将除`#include`头文件之前的其他函数定义都`#if 0`，只留下有错误的函数定义，再查看错误原因
*  这个时候一般可能是代码中使用（非预期使用）了其他头文件定义的宏定义导致的错误，或者就是一个很难发现的拼写错误，如`1一I`，`0—O`之类很难发现的错误。



上面是编译错误，如果无法编译呢？命令找不到command not found，头文件找不到No such file or directory等影响编译的错误

* 如果提示命令找不到command not found
    * 需要检查path设置，看看PATH是否包含编译程序GCC路径。
    * Windows 使用";"：`set PATH=$PATH;<your_gcc_path>`
    * Linux使用":"：`set PATH=$PATH:<your_gcc_path>`
*   如果编译提示头文件找不到`No such file or directory`
    * 需要检查GCC的`-I`选项是否包含头文件所在目录。一般不需要显示指定标准头文件目录和源码目录的头文件，如果引用其他目录头文件，需要`-I<DIR>`指定。`gcc -I /home/wt/my_dir a.c -o a.o`
* 如果是链接的时候提示库文件找不到
    * 需要检查 `-L`是否包含库文件所在目录，使用`-L<dir>`指定。
* 每次使用GCC的时候指定一堆头文件目录和库文件目录，很麻烦
    * Makefile帮你一劳水逸



### 链接错误

* 未定义符号
    * 如`mtest.o: In function 't1' mtest.c:(text+0x74): undefined reference to 't2'`
    * 这类问题一般缺少函数或全局变量定义
    * 如果代码里有定义，则可能是有编译错误，请查看源文件对应的目标文件是否生成
*   符号重复定义
    * 如`t_div.o: In function 't1': t_div.c（text+0x0）: multiple definition of 't1'`
    *  这类问题一般是多个源文件重复定义函数、全局变量等，查看代码修改或删除重复的定义即可
    *   如果没有重复定义，也有可能是目标文件重复包含导致的，重点查看链接命令使用的目标文件和库文件是否重复包含了重复函数、全局变量对应的目标文件。
* 重定位截断
    * 如`In function '__init':: relocation truncated to fit: R_PPC_REL24_exec_ctors`
    * 这类问题一般是代码段、数据段过大，请对比最近修改，并查看代码段、数据段等是否处在临界值左右。PPC ARM MIPS等RISC系统都存在类似问题，如PPC和ARM代码段是32M，mips是256M。



## GCC选项

### GCC参考

* GCC手册
    *  可在 https://gcc.gnu.org 下载
*   特别说明：GCC的选项都是区分大小写，对于冲突的选项以后面的为准。
*   全局开关：如`-x`、`-c`、`-E`、`-S` 等指定语言或控制预编译、编译、汇编、链接四个过程，`-o` 指定输出文件名
    *   `gcc -x` g++指定使用c++ 语言
    *  GCC缺省包括预编译、编译、汇编、链接处理，如`gcc a.s -o a.bin`
    *  `gcc -c a.c -o a.o` 只生成目标文件（预编译、编译、到汇编结束）
    *   `gcc -E a.c > a.i`只预编译
    *   `gcc -S a.c -o a.s` 只预编译和编译（生成汇编语言文件a.o）
    *   `-o file` 将输出文件保存在file中，没有-o选项时，可执行文件保存为a.out，source.suffix的目标文件source.o，汇编文件source.s，所有预编译输出到标准输出设备，需要使用重定向保存到文件中。



### 编译选项

#### C语言选项

* `-ansi`：标准ISO C90扩展，如`__asm__`、`__extension__`等
* `-std=xx`：xx可以指定c89、c99、gnu89，gnu99、c++98、gnu++98等，对于c语言缺省是gnu89，c++缺省时gnu++98。常用的gnu扩展包括0长度数组，指定函数属性、指定结构体成员初始化等。
* `-fno-builtin`：不识别GCC的内置函数
* `-funsigned-char`：指定char为unsigned，未指定时有些机器可能signed
* `-fsigned-char`：指定char为signed



#### C++语言选项

*   `-fall-virtual`：将所有的成员函数当成虚函数处理
*  `-ffor-scope`/`-fno-for-scope`：前者将for初始语句定义的变量只在循环内有效，不指定两者都不生效，但是告警以防止有错误
*   `-nostdinc++`：不查找c++标准头文件（用于编译g++标准库使用）



#### 告警选项

*  `-w`：禁止所有告警（注意是小写）
*  `-Werror`：使所有的警告报告为错误。
*  `-Wchar-subscripts`：对数组下标为char类型给出警告。这是一个常引发错误的原因，因为程序员经常会忘记这种类型在一些机器上是有符号数。
*  `-Wcomment`： 在`"/*"`标明的注释里又出现了`"/*"`，或`"//"`标明的注释里出现了`"\" `，则给出警告。
*   `-Wformat` ：检查printf和scanf等的调用，确定提供的参数类型与给出的类型说明一致。
*  `-Wreturn-type` ：函数定义其返回值类型缺省为int类型时给出警告。在返回值类型不为void类型的函数中return语句没有返回值也给出警告。
*  `-Wunused`：如果一个变量声明后没有使用，一个函数声明为静态但没有被定义，一个标号被声明而没有使用，一个语句计算出的结果没有被使用，则给出警告。要禁止对一个表达式产生此警告，简单地把该表达式转换为void。
*   `-Wuninitialized`：一个自动变量没有被初始化就被使用。
*  `-Wsign-compare`：对有符号数与无符号数的比较给出警告
*  `-Wno-error=format-security`：关闭格式化字符串安全检查，可以允许一些不符合安全规范的格式化字符串。
*  `-Werror=pointer-to-int-cast`：将指针转换为整数时产生警告，如果出现这种警告则视为错误。
*  `-Werror=int-to-pointer-cast`：将整数转换为指针时产生警告，如果出现这种警告则视为错误。
*  `-Werror=type-limits`：对于类型范围的限制产生警告，如果出现这种警告则视为错误。
*  `-Wpointer-arith`：对于指针运算产生警告，如果出现这种警告则视为错误。
*  `-Wimplicit-function-decleration`：启用隐式函数声明警告，以便在编泽时可以检测到未声明的函数。
*  `-Wunused-command-line-argument`：启用未使用命令行参数警告，以便在编译时可以检测到未使用的命令行参数。



#### 调试选项

*  `-g`：用操作系统的格式（stabs, COFF, XCOFF, or DWARF）生成调试信息。
*  `-p`：生成额外代码来写描述信息，适合分析程序"prof"使用。在编译想获取数据的源文件时必须使用此开关，而且在连接时也必须使用此开关。
*  `-pg`：生成额外代码来写描述信息，适合分析程序"gprof"使用。在编译想获取数据的源文件时必须使用此开关，而且在连接时也必须使用此开关。
*  `-ftest-coverage`：生成后缀为.gcno的文件由gcov用于覆盖率统计
*   `-save-temps`：保存临时文件，譬如预编译文件、汇编文件
*   `-fno-omitframe-pointer`：禁用省略帧指针的优化，以便在调试时可以更好地跟踪函数调用堆栈。



#### 优化选项

*  全局优化`-O`
    *  `-O1`优化。优化编译会花更长的时间、更多的内存。
        *  不使用`-O`开关，编译器的目标是减少编译开销，进行调试以产生期望的结果。
        *  使用`-O1`开关，编译器力图减少代码大小和运行时间。

    *  `-O2`进一步优化。（建议使用）
        *  进行几乎所有支持的优化，但不进行空间速度平衡。编译器在使用`-O2`开关时不进行循环展开或函数内嵌。

    *  `-O3`更进一步优化。
        *  打开所有`-O2`开关指定的优化项，并打开`inline-functions`开关。

    *  `-O0`不进行优化。
    *  `-Os`为大小进行优化。
        *  打开所有`-O2`开关指定的不显著增加代码大小的优化项，同时还进行针对减少代码量的进一步优化。

    *  `-fFLAG`形式的开关定义了与机器无关的标识。大多数标识都有肯定和否定的形式；`-ffoo`的否定形式为`-fno-foo`。
    *  如果使用了多个带或不带数字的`-O`开关，只有最后一个开关起作用。
    *  有时优化选项可能有一定的副作用，如遇到一些怪异问题，可试试关闭优化选项。

*  具体优化
    *  `-funroll-loops`：循环展开可以减少循环的次数，对程序的性能带了两方面的提高。
        *  一是减少了对循环没有直接页献的计算，比如循环计数变量的计算，分支跳转指令的执行等。
        *  二是提供了进一步利用机器特性进行的优化的机会。

    *  `-fvisibility=hidden`：设置默认的ELF镜像中符号的可见性为隐藏。使用这个特性可以非常充分的提高连接和加载共享库的性能，生成更加优化的代码
    *  `-ftree-vectorize`：自动向量化，实现循环中的自动向量化和串行代码中的自动向量化
    *  `-fno-tree-vectorze`：禁用向量化优化，即不使用SIMD指令集来加速代码执行。
    *  `-finline-functions`：启用函数内联优化，将函数调用替换为函数体，减少函数调用的开销。
    *  `-fno-math-errno`：禁用数学库函数的错误处理机制，可以提高数学库函数的执行速度。
    *  `-fno-rtti`：关闭运行时类型信息（RTTI）支持，可以减小程序的体积和运行时开销。
    *  `-fno-exceptions`：关闭异常处理支持，可以减小程序的体积和运行时开销。
    *  `-flax-vector-conversions`：启用宽松的向量类型转换，可以提高程序的性能。
    *  `-ffunction-sections`：将每个函数放在单独的代码段中，以便在链接时可以更好地优化代码。
    *  `-fdata-sections`：将每个全局变量放在单独的数据段中，以便在链接时可以更好地优化代码。




#### 预编译选项

* `-isystem DIR`：把一个目录加到第二个包含路径的开头，并把它标识为系统目录，从而获得与标准系统目录相同的特殊对待。
* `-nostdinc`：不在标准系统目录下搜索头文件，只搜索用`-I`开关指定的目录（以及当前目录）。同时使用`-nostdinc`和`-I-`开关，可以把包含文件的搜索路径限定在那些明确指出的目录里。
*   `-undef`：不预定义任何非标准的宏（包括结构标识）。
*  `-DMACRO`：定义宏MACRO为字符串"1"。
*  `-DMACRO=DEFN`：定义宏MACRO为DEFN。命令行中所有的`-D`开关都在 `-U`之前进行处理
*  `-UMACRO`：取消宏MACRO的定义。`-U`开关在所有的`-D`开关之后进行处理，但在`-include`和`-imacros`开关之前进行处理。
*  `-M`：生成Makefile依赖文件。告诉预处理器输出适合"make"的一个规则，描述各个对象文件的依赖关系。`-MM`，`-MD`与`-M`略有差异



#### 查找目录选项

*  `-B<PREFIX>`：这个开关指定可执行文件、库文件、包含文件和编译器自己的数据文件的存放地点。
*  `-I<DIR>`：把目录DIR加在查找头文件的目录列表前面。这被用来覆盖一个系统头文件，替换为自己的版本，因为这些目录会在系统头文件目录前被查找。如果使用了多个`-I`开关，则按从左至右的顺序进行查找，然后才是标准的系统目录。
*  `-I- <dir>`：在`-I-`开关之前使用`-I`指定的目录只对`#include "FILE"`进行查找，不查找`#include <FILE>`。在`-I-`开关之后使用`-I`指定的目录查找所有的`#include`指令。（通常几乎所有的`-I`目录都是这样使用的）
*  `-L<DIR>`：把目录DIR加到查找`-I`的目录列表上。



#### 安全编译选项

##### 通用

| 选项         | 用法                                                         | 选项说明                                                     |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 栈保护       | `-fstack-protector --param ssp-buffer-size=4`                | 堆栈保护，仅对局部变量中包含字符数组声明并且字符数组长度超过4个字节的函数实施堆栈保护。 |
|              | `-fstack-protector --param ssp-buufer-size=4 -Wstack-protector` | 该选项对于包含长度小于4个字节字符串数据组的函数没有进行保护，对这类函数进行告警。 |
|              | ` -fstack-protector-all`                                     | 对所有函数进行堆找保护。                                     |
| 堆栈不可执行 | `noexecstack`                                                | 设置堆栈中的数据只可以读和写，不可执行。                     |
| 库搜索路径   | `-Wl, --disable-new-dtags, --rpath [path]`                   | rpath选项是链接选项，主要用于防护LD_LIBRARYPATH替换同名动态库的攻击。<br/>通过加入此选项可以指定一个运行时动态库搜索的路径，该路径的搜索优先级高于LD_LIBRARY_PATH指定的路径。 |
| 地址无关     | `-fPIC`                                                      | 指令中那些ELF加载时需修改的部分分离出来，跟数据部分放在一起，这样指令部分可保持不变，而数据部分每个进程拥有一个备份。 |
| GOT表保护    | `-Wl, -z, relro, -z, now`                                    | 全局偏移表GOT只读。                                          |
|              | `-Wl, -z, relro`                                             | 部分重定向只读只是保护了.ctors、.dtors、.jcr、.dynamic、.got等节，使得这些节只读，但是和PLT相关的.got.plt节依然是可重写的。 |
| 随机化       | `-fPIE`                                                      | GCC和操作系统结合，提供的地址无关可执行功能。具备PIE的可执行文件，在加载执行时可像共享库一样随机加载。有研究表明：PIE可有效降低固定地址类攻击、缓冲溢出类攻击的成功概率。 |
| FS           | `-D_FORTIFY_SOURCE=1 -O1`                                    | 对于程序中固定大小的缓存进行操作时。                         |
|              | `-D_FORTIPY_SOLRCB=2 -O2`                                    | 提供更强的保护程度，该选项能提供编译时和运行时的双重检查保护。 |
| visibility   | `-fvisibility-hidden`                                        | 设置默认的ELF镜像中符号的可见性为隐藏。<br/>使用这个特性可以非常充分的提高连接和加载共享库的性能，生成更加优化的代码，提供近乎完美的API输出和防止符号碰撞。我们强烈建议你在编译任何共享库的时候使用该选项。 |
|              | `-fvisibility-protected`                                     | Protected表明符号将会导出到动态符号表，但是该定义模块中的引用会绑定到本地符号，符号不能被其它模块覆盖。 |
|              | `-fvisibility=default`                                       | 总是公开并其它模块可见，在共享库声明的实体可以被覆盖。       |
| 整数溢出检查 | `-ftrapv`                                                    | 检测有符号整数加、减、乘三种运算的运行时溢出，并在溢出时触发SIGABRT。 |
| 栈检查       | `-fstack-check`                                              | 检查栈是否超过可用的栈空间。                                 |



##### Linux平台（用户态）

| 选项           | 用法                                                         | 实施建议 | 作用阶段       | 作用范围                                              | 说明                                                         |
| -------------- | ------------------------------------------------------------ | -------- | -------------- | ----------------------------------------------------- | ------------------------------------------------------------ |
| ASLR           | `echo 2 > /proc/sys/kernel/randomize_va_space`               | 必选     | 运行系统配置   |                                                       | 需要保护系统随机化开启，randomize_va_space=2                 |
| 栈保护         | `-fstack-protector-all`<br/>`-fstack-protector-strong`       | 必选     | 编译选项       | 可用于：可重定位文件（.o）、动态库、ELF格式可执行程序 | GCC4.9版本及以上落地`-fstack-protector-strong`；GCC4.9版本以下落地`-fstack-proteotor-all`，因为`strong`带来的性能损失要小于`-fstack-protector-all`，而GCC4.9版本才支持`strong`；<br/>对于性能原因不能落地的需要详细的数据提供审核；<br/>windriver linux 4.3 + MIPS的环境不支持该特性。 |
| GOT表保护      | `-Wl, -z, relro`                                             | 必选     | 链接选项       | 可用于：动态库、ELF格式可执行程序                     |                                                              |
| 立即绑定       | `-z, now`                                                    | 必选     | 链接选项       | 可用于：动态库、ELF格式可执行程序                     | 如果有动态库循环依赖的问题，先解决循环依赖再执行该选项。会使包含动态库的程序启动变慢，但会使用第一次调用函数速度更快。 |
| 堆栈不可执行   | `-Wl, -z, noexecstack`                                       | 必选     | 链接选项       | 可用于：动态库、ELF格式可执行程序                     | 如果有内嵌函数，会导致功能错误。需要先用`-Wtramplines`进行检测，GCC4.6.4版本及以上。<br>windriver linux 4.3普通版本不支持该特性。<br>windriver linux 6 + MIPS的环境不支持该特性。 |
| 地址无关       | `-fPIC`                                                      | 必选     | 编译选项       | 可用于：可重定位文件（.o）、动态库                    | 此处不加PIE。                                                |
| 随机化         | `-fPIE -pie`                                                 | 必选     | 编译、链接选项 | 可用于：ELF格式可执行程序                             | 关注对应的热补丁版本是否支持PIE，不支持的场景下不建议使用该选项；此处不加PIC。 |
| 动态库搜索路径 | `-Wl, --disable-new-dtags, --rpath, /libpath1:/libpath2`<br/>`-Wl, --enable-new-dtags, --rpath, /libpath1:/libpath2` | 禁选     | 链接选项       | 可用于：动态库、ELF格式可执行程序                     | 二进制特征会显示rpath/runpath路径，攻击者会更加容易构造rpath类攻击。 |
| FS             | `-D_FORTIFYLSOURCE=2 -O2`                                    | 可选     | 编译选项       | 可用于：可重定位文件（.o）、动态库、ELF格式可执行程序 | 先在分支版本添加，重点做性能测试，很据测试结果取舍。         |
| visibility     | `-fvisibility=hidden`                                        | 可选     | 链接选项       | 可用于：动态库                                        | 需要进行代码整改。                                           |
| 整数溢出检查   | `-ftrapv`                                                    | 可选     | 编译选项       | 可用于：可重定位文件（.o）、动态库、ELF格式可执行程序 | 性能影响较大，建议在Debug版本中实施，Release版本不实施。     |
| 栈检查         | `-fstack-check`                                              | 可选     | 编译选项       | 可用于：可重定位文件（.o）、动态库、ELF格式可执行程序 | 性能影响较大，建议在Debug版本中实施，Release版本不实施。     |
| 删除符号表     | `-s(strip)`                                                  | 可选     | 链接选项       | 可用于：动态库、ELF格式可执行程序                     | 会影响齐品定位网上问题。                                     |
| 告警选项方案   | `-Wformat=2`<br/>`-Wfloat-equal`<br/>`-Wshadow`              | 可选     | 编译选项       | 可用于：可重定位文件（.o）、动态库、ELF格式可执行程序 | C++开发的代码，不使用`-Wshadow`。                            |



##### Android平台（后台）

| 选项           | 用法                                                         | 实施建议 | 作用阶段       | 作用范围                                              | 说明                                                         |
| -------------- | ------------------------------------------------------------ | -------- | -------------- | ----------------------------------------------------- | ------------------------------------------------------------ |
| ASLR           | `echo 2 > /proc/sys/kernel/randomize_va_space`               | 必选     | 运行系统配置   |                                                       | 需要保护系统随机化开启，randomize_va_space=2                 |
| 栈保护         | `-fstack-protector`                                          | 必选     | 编译选项       | 可用于：可重定位文件（.o）、动态库、ELF格式可执行程序 | GCC4.9版本及以上落地`-fstack-protector-strong`；GCC4.9版本以下落地`-fstack-proteotor-all`，因为`strong`带来的性能损失要小于`-fstack-protector-all`，而GCC4.9版本才支持`strong`； |
| GOT表保护      | `-Wl, -z, relro`                                             | 必选     | 链接选项       | 可用于：动态库、ELF格式可执行程序                     |                                                              |
| 立即绑定       | `-z, now`                                                    | 必选     | 链接选项       | 可用于：动态库、ELF格式可执行程序                     | 如果有动态库循环依赖的问题，先解决循环依赖再执行该选项。会使包含动态库的程序启动变慢，但会使用第一次调用函数速度更快。 |
| 堆栈不可执行   | `-Wl, -z, noexecstack`                                       | 必选     | 链接选项       | 可用于：动态库、ELF格式可执行程序                     | 如果有内嵌函数，会导致功能错误。需要先用`-Wtramplines`进行检测，GCC4.6.4版本及以上。 |
| 地址无关       | `-fPIC`                                                      | 必选     | 编译选项       | 可用于：可重定位文件（.o）、动态库                    | 此处不加PIE。                                                |
| 随机化         | `-fPIE -pie`                                                 | 必选     | 编译、链接选项 | 可用于：ELF格式可执行程序                             | 关注对应的热补丁版本是否支持PIE，不支持的场景下不建议使用该选项；此处不加PIC。 |
| 删除符号表     | `-s(strip)`                                                  | 必选     | 链接选项       | 可用于：动态库、ELF格式可执行程序                     | 会影响齐品定位问题。                                         |
| 动态库搜索路径 | `-Wl, --disable-new-dtags, --rpath, /libpath1:/libpath2`<br/>`-Wl, --enable-new-dtags, --rpath, /libpath1:/libpath2` | 禁选     | 链接选项       | 可用于：动态库、ELF格式可执行程序                     | 二进制特征会显示rpath/runpath路径，攻击者会更加容易构造rpath类攻击。 |
| FS             | `-D_FORTIFYLSOURCE=2 -O2`                                    | 可选     | 编译选项       | 可用于：可重定位文件（.o）、动态库、ELF格式可执行程序 | 先在分支版本添加，重点做性能测试，很据测试结果取舍。         |
| visibility     | `-fvisibility=hidden`                                        | 可选     | 链接选项       | 可用于：动态库                                        | 需要进行代码整改。                                           |
| 整数溢出检查   | `-ftrapv`                                                    | 可选     | 编译选项       | 可用于：可重定位文件（.o）、动态库、ELF格式可执行程序 | 性能影响较大，建议在Debug版本中实施，Release版本不实施。     |
| 栈检查         | `-fstack-check`                                              | 可选     | 编译选项       | 可用于：可重定位文件（.o）、动态库、ELF格式可执行程序 | 性能影响较大，建议在Debug版本中实施，Release版本不实施。     |
| 告警选项方案   | `-Wformat=2`<br/>`-Wfloat-equal`<br/>`-Wshadow`              | 可选     | 编译选项       | 可用于：可重定位文件（.o）、动态库、ELF格式可执行程序 | C++开发的代码，不使用`-Wshadow`。                            |



##### 详解

###### 堆栈保护-SP

* 在缓冲区和控制信息间插入一个canary word。当缓冲区被溢出时，在返回地址被覆盖之前canary word会首先被覆盖。通过检查canary word的值是否被修改，就可以判断是否发生了溢出攻击。
*  使用堆栈保护选项在对字符数组进行溢出防护的同时，还有意将局部变量中的数组放在函数栈的高地址，而将其他变量放在低地址。



###### 堆栈不可执行-noexecstack

* 缓冲区溢出成功后都是通过执行shellcode来达到攻击的目的，而shellcode一般都是在缓存区里，只要操作系统限制堆栈中的不可执行，一旦堆栈中的数据被执行立即报告错误，并退出，那么溢出成功后也不能执行shellcode，从而达到对应用安全防护的目的。
*  在C语言中是允许嵌套函数调用的，嵌套函数的调用需要在运行时在栈空间动态生成一小段代码，并且要求堆栈是可执行的，添加noexecstack选项后，嵌套函数会无法执行。
* 主要用于防护LD_LIBRARY_PATH替换同名动态库的攻击。通过加入此选项可以指定一个运行时动态库搜索的路径，该路径的搜索优先级高于LD_LIBRARY_PATH指定的路径。
*   RPATH选项可略微提升程序的加载效率和速度。
*   建议产品使用该选项。



###### 位置无关代码-fPIC

* 节省内存空间：加载时非PIC方式共享库SO，由于会发生代码段重定位，这就导致每个进程的代码段都是独特的。无法实现多个进程与此相关代码段映射到同一块物理内存。而PIC方式，不会在代码段发生重定位，每个进程的代码段都是相同的，所有操作系统在映射时，可将多个进程与此相关的代码段映射到同一块物理内存。所有可看出通过这种方式可以节省物理内存，提高内存利用率。
*  对于内存有限的嵌入式设备，PIC可在一定情况下，缓解内存不足的问题。
*  延迟绑定：将共享库so加载时发生的重定位延迟到运行时完成（即延迟绑定），这种方式可降低共享库SO加载时的CPU开销。提升可执行程序的启动速度。
*  防止攻击：非PIC的So加载时需要重定位，重定位则需要代码段具备写权限，这会为攻击创建条件：如使用mmap将代码段映射并使用mprotect将其改为可写，再将恶意代码复制进来，SO文件再次被使用时恶意代码就会执行。PIC的SO则不会开放写权限，从而阻止此类攻击。



###### GOT保护-RELRO

* 动态链接的ELF二进制程序使用称为全局偏移表（GOT）的查找表去动态解析位于共享库中的函数。攻击者通过缓冲区溢出修改GOT表项的函数地址值来达到攻击的目的。通过增加RELRO选项，可以防止GOT表被恶意重写。
*   GOT表全保护影响程序加载速度，建议所有产品使用部分保护功能，部分保护对影响基本没有影响。



###### 位置无关可执行-fPIE

* PIE（Position-Independent-Executable）是GCC和操作系统结合，提供的地址无关可执行功能。具备PIE的可执行文件，在加载执行时可像共享库一样随机加载。有研究表明：PIE可有效降低固定地址类攻击、缓冲溢出类攻击的成功概率。
*   ASLR是基础，只有操作系统开启ASLR功能，`-fPIE -pie`选项添加的随机化特征才会在程序加载和运行时展现。



###### FORTIFY_SOURCE

* GCC编译器和GLIBC库配合，协同提供在编译时和运行时对固定大小的（不论是动态分配的还是静态声明的内存空间）缓冲区的访问检查。
* FORTIFY_SOURCE是一个编译器选项，用于增强程序的安全性。它是GNU C库提供的一个特性，可以在编译时自动检测一些常见的安全问题，例如缓冲区溢出、格式化字符串漏洞等。
* 在使用FORTIFY_SOURCE时，编译器会自动将一些函数替换为更安全的版本，这些函数包括strcpy、memcpy、sprintf等。替换后的函数会在运行时进行一些检查，以确保不会发生缓冲区溢出等安全问题。
* FORTIFY_SOURCE可以帮助开发人员在编译时发现一些常见的安全问题，从而提高程序的安全性。但需要注意的是，FORTIFY_SOURCE并不能保证程序的完全安全，开发人员仍需要进行其他安全措施，如输入验证、错误处理等。



###### 动态符号表优化-fvisibility

* 设置默认的ELF镜像中符号的可见性隐藏。使用这个特性可以非常充分的提高连接和加载共享库的性能，生成更加优化的代码，提供近乎完美的API输出和防止符号碰撞。在库中减少符号的数目还可以减少库的内存印迹，减少动态连接器的工作量。我们强烈建议在编译任何共享库的时候使用该选项。动态连接器装载和识别的符号越少，程序启动和运行的速度就越快。
*  建议用`-fvisibility=hidden`隐藏本地函数，用以下两种方式向接口函数导出到动态符号表。



###### 整数溢出检查-ftrapv

*  使用了`-ftrapv`选项后，执行有符号整数间的加、减、乘运算时，不是通过CPU的指令，而是用包含在GCC附属库libgcc.c里的函数来实现。
*   对性能影响较大，建议在Debug版本或仿真环境中使用该选项。



###### 栈检查-fstack-check

* stack-check在编译时检查程序中栈空间，如果超过编译告警阀值则产生告警；然后在程序中生成额外的指令来检查运行时栈不会被溢出，stack-check选项会在每个栈空间最低底部设置一个安全的缓冲区，如果函数中申请的栈空间进入安全缓冲区，则触发一个Storage_Error异常。
* 对性能影响较大，建议在Debug版本或仿真环境中使用该选项。



#### 其他选项

* `-march=armv8-a`：指定编译器生成ARMv8-A架构的指令集代码，以便在支持该架构的处理器上运行。
* `-mcpu=generic`：指定编译器生成通用的CPU指令集代码，以便在不同的处理器上运行。
* `-mfoat-abi=softfp`：指定浮点运算的ABI（应用程序二进制接口），以便在不同的处理器上可以正确地处理浮点数。
* `-fpermissive`：放宽编译器对C++标准的严格要求，允许一些不符合标准的语法。