# OpenCL

## 基本概念

### 简介

OpenCL（Open Computing Language，开放计算语言）是异构平台并行编程开发标准，也是并行编程框架。

OpenCL支持数据并行和任务并行。

OpenCL支持多种处理器芯片，主要包括CPU、GPU、DSP和FPGA。

OpenCL提高了底层硬件结构的抽象模型，目的是使用一套通用的API，即减轻开发人员的编程难度，又让开发人员写出高效可移植的代码。



OpenCL包括两个部分：

* OpenCL C语言（OpenCL 2.1开始使用OpenCL C++作为内核编程应用）和主机端API
* 硬件架构抽象



OpenCL异构并行计算架构：

- **平台模型（platform model）**：将硬件抽象为主机（host）或设备（device）。
  - 指定一个主机处理器，用于任务调度。
  - 指定一个或多个设备处理器，用于执行OpenCL内核（OpenCL C kernel）。
- **内存模型（memory model）**：定义了内存对象的类型，抽象了内存层次，内核无需了解其使用的内存实际架构。
  - 区分了主机和核中用到的内存结构、内容和行为。
  - 定义了执行顺序关系和同步需要用到的规则。

- **执行模型（execution model）**：定义了OpenCL在主机上运行的环境该如何配置，以及主机如何指定设备执行某项任务。
  - 主机运行环境。
  - 主机与设备交互的机制。
  - 配置内核时使用的并发模型。
    - 并发模型：定义如何将算法分解成OpenCL工作项和工作组。
- **编程模型（programming model）**：定义了并发模型如何映射到实际物理硬件。





### 平台模型

#### 组成

OpenCL平台模型由主机及其相连的一个或多个OpenCL设备组成。

* 主机包括X86或ARM处理器的计算平台。
* 设备可以是CPU（也可以将主机端的CPU作为OpenCL设备）、GPU、DSP、FPGA或硬件商提供、OpenCL开发商支持的任何其他处理器。



平台模型包括一个主机和一个或多个设备，每个设备有一个或多个计算单元（Compute Units， CU），每个计算单元由一个或多个处理元素（Processing Elements， PE）组成。

处理元素（PE）是设备上执行数据计算的最小元素。



```mermaid
classDiagram

Host "1" -- "1..*" Device
Device "1" *-- "1..*" ComputeUnits
ComputeUnits "1" *-- "1..*" ProcessingUnits
```



#### 控制流属性

* converged：一个计算单元（CU）中的处理元素（PE）都在以相同的顺序执行指令。针对跨处理元素（PE）执行单个指令流的硬件优化适合converged控制流
* diverged: 处理元素（PE）之间控制流不同。

内核通常以converged控制流开始执行，两种控制流都会在一个内核里发生。这种机制为能在OpenCL上实现的算法提供了很大的灵活性。





### 执行模型

OpenCL程序包括**主机端程序**和**内核（kernel）程序**

* 主机端程序（host program）运行在主机处理器上，主机端程序以命令方式将内核程序从主机传输到设备。
  * 创建上下文（context）以及命令通道（command queue），提交命令，copy数据到设备（device）上等。

* 内核程序（kernel program）定义在程序（program）中，在设备（device）的处理单元上执行。计算在工作项（work-group）中执行的工作组（work-item）进行。内核通常是一些计算量大、逻辑简单的函数。设备通过内核将输入数据计算后输出给主机。





#### 上下文

上下文由主机创建和管理，执行内核。



上下文定义了内核执行的环境，包括：

* **设备**：平台包含一个或多个设备。
  * OpenCL支持的设备有CPU、GPU、DSP、FPGA等。主机可以根据具体问题和运行的内核选择设备的组合方案（例如1个CPU、1个GPU、1个CPU+1个GPU、多个GPU等方案），在定义的上下文中包含设备方案。
* **内核对象**：设备上运行的内存函数。
* **程序对象**：实现整个内核程序的源代码和目标二进制码。
  * 上下文包含一个或多个程序对象。
  * 程序对象可以理解为动态库。可以从程序对象中选取内核使用的函数。
  * 程序对象在运行时由主机程序构建。
    * 从程序源代码中构建。
    * 从源代码中已经编译好的代码上构建。
* **内存对象**：对主机和设备可见的对象，内核执行时操作内存对象的实例。
  * 在主机上定义。
  * 在主机与设备间交换数据。





#### 命令队列

主机通过命令队列（command-queue）与设备（device）进行交互。



一个命令队列在上下文中会与一个设备进行关联。



同一上下文中可以多个命令队列，独立执行。对主机端程序可见的事件对象可被用于定义不同命令队列中各命令之间的同步点。



命令由主机或运行在设备中的内核（支持OpenCL 2.0以上设备）提交给命令队列，然后等待，直到被调度到OpenCL设备上执行。

命令的类型：

* 内核入队命令（Kernel-enqueue command）
  * 在一个设备执行内核，需要将内核入队到与该设备关联的命令队列。
* 内存命令（Memory commands）
  * 在主机与设备内存对象间传输数据。
  * 将内存对象映射到主机地址空间，或取消内存对象映射到主机地址空间。
* 同步命令（Synchronization commands）
  * 对命令队列中需要执行的命令施加执行顺序约束，如只有某个命令执行完成其他命令才能开始执行。



命令执行类型

* 阻塞式命令：在命令完成之前OpenCL API接口不会返回。
* 非阻塞式命令：立即返回，需要程序员保证入队命令的执行顺序，入队命令需要在必要资源可用之后执行。

实际的命令可能是**异步执行**的：主机或运行在设备的内核将命令进入命令队列，无需等待命令完成，就可以继续工作。如果需要等待命令完成，可以利用命令执行相关的同步机制进行同步。



在同一个命令队列中的命令在命令队列中执行方式

* 按序（in-order）执行：命令按其进入命令队列中的先后顺序执行，并按顺序完成。
* 乱序（out-of-order）执行：命令以任意顺序执行，通过显式的同步点或显式事件依赖项来约束顺序。



只有在内核实例执行时才会做与内核相关的计算。如果通过主机程序多次启动内核实例进行执行，会增加开销或加重应用程序控制流。一个有效的办法是从内核内部嵌套内核命令，运行在设备上的内核（父内核）入队一个内核实例（子内核）到设备端命令队列，无需主机程序参与。



无论是子内核还是父内核，每个命令经过六个状态；

1. Queue：这条指令已入队。指令会一直在队列中，直到被显式冲掉或被其他指令隐式冲掉。
2. Submitted：命令从命令队列中被冲掉，提交至设备上运行。从命令队列出队后，命令会在前置条件都满足的情况下执行。
3. Ready：所有命令需要的前置条件都满足。这条命令与内核入队命令相关的工作组集合，会进入设备资源池等待调度执行。
4. Running：命令执行开始。在核入队列命令的情况下，一个或多个相关的工作组开始执行。
5. Ended：命令执行结束。内核入队命令结束，所有相关的工作组都结束执行。
6. Complete：命令和子命令都结束执行，事件对象的状态转移到CL_COMPLETE。

命令间通过事件对象进行通信。把命令相关联的状态设为CL_COMPLETE即为成功执行指令。把事件状态设为负值即为执行指令失败，异常终止。在这种情况下，与异常终止指令相关的指令和在同一个上下文中的所有其他指令可能都无法再获取，它们的行为由实现定义。



提交至设备的命令只有在所有限制命令顺序的前置条件都满足时才会launch。这些前置条件有以下三种资源：

* 执行顺序的限制。e.g. barrier。
* 依赖关系。
* 全局变量的Non-trivial C初始化器或C++构造函数。此时OpenCL的C/C++编译器需要进行C的初始化或者C++的构造来生成程序初始化内核。这些内核必须在同一程序在同—设备上的其他核之前执行。程序初始化核的ND range是`{1, 1, 1}`。多个程序连接在一起时，未定义程序初始化核的执行顺序。





#### 内核

OpenCL三类内核

* **OpenCL内核**：用OpenCL C编程语言编写，并用OpenCL C编译器编译的函数。所有OpenCL实现都必须支持OpenCL内核和OpenCL C编程语言。
* **原生内核**：OpenCL之外创建的函数，在OpenCL中可以通过一个函数指针来访问。例如，这些函数可以是主机源代码中定义的函数，或者是从一个专门库导出的函数。需要指出的是，执行原生内核是OpenCL的一个可选功能，原生内核的语义依赖于具体OpenCL实现。
* **内建（built-in）内核**：被绑定到特定设备，并不需要源码编译成程序对象的函数。常见用法是针对公开固定函数硬件或固件，将它们关联到一个特定的OpenCL设备或自定义设备。内建内核是OpenCL扩展功能，内建内核语义依赖于具体OpenCL实现。



可使用OpenCL C源程序，SPIR-V中间语言或者二进制obj文件提供程序。OpenCL的编译器将这些形式的程序翻译为可执行obj。



设备内核代码编译器分类

* online：在主机端程序执行期间使用标准API调用。
* offline：使用平台特定的方法，在主机端程序控制之外调用。

OpenCL runtime允许开发者执行之前编译好的设备程序，能够加载、执行之前编译好的设备程序。一般设备只支持built-in内核，不能使用内核语言编程。



平台profile分类：

* Full profile： 为所有设备提供online compiler
* Embedded profile：不是必须提供online compiler

用于特殊用途的设备可作为built-in内核。平台提供API，用于枚举和调用built-in内核。



OpenCL设备通常没有IO处理能力，IO操作通常由主机承担，这意味着程序开始执行时，数据通常在主机上，设备需要从主机上获取数据，在设备完成计算后，又要将数据从设备复制到主机。



OpenCL运行时将会创建一个整数索引空间。索引空间是OpenCL支持的一个N维网格，称为NDRange，其中N为1、2或3。三个长度为N的数据确定了NDRange的以下特征：

- 每个维度索引空间（或全局大小）的范围；
- 一个偏移指数F表明每个维度的初始索引值（默认为0）；
- 一个工作组（局部大小）每个维度大小。



内核实例：

* 内核
* 关联内核参数的参数值
* 定义索引空间的参数



工作项：索引空间的每个点，用于执行内核实例。

工作项的全局ID：工作项在索引空间的坐标。

工作项的局部ID：工作项在工作组中的坐标。

虽然工作项执行内核定义的相同的指令，但是由于工作项的全局ID不同，工作项的行为可能不同。

工作项提供对索引空间细粒度的分解。



工作组：由多个工作项组成，数量由内核入队时的参数决定。

工作组ID：工作组在索引空间的坐标。

工作组提供对索引空间粗粒度的分解。



定义一个二维的索引空间：

工作项在索引空间的大小为(Ax, Ay)

工作项在工作组的大小为(Bx, By)

工作组在索引空间的大小为(Cx, Cy)
$$
Cx = ceil(Ax / Bx)\\Cy = ceil(Ay / By)
$$
工作项的全局ID为(Gx, Gy)

工作项的全局偏移为(Fx, Fy)

工作项的局部ID为(Lx, Ly)，范围从(0, 0)到(Bx-1, By-1)

工作组ID为(Wx, Wy)，范围从(0, 0)到(Cx-1, Cy-1)
$$
Gx = Wx * Bx + Lx + Fx\\Gy = Wy * By + Ly + Fy
$$





### 内存模型

#### 内存区域

内存区域包括主机和设备的内存。



类型：

* 主机内存（host memory）：主机直接可用的内存，OpenCL并未定义主机内存的具体行为。通过OpenCL API或者共享虚拟内存接口，实现内存对象在主机与设备间的传输。
* 全局内存（global memory）：这个内存区域允许上下文中任何设备中所有工作组的所有工作项的读写，工作项可以读写内存对象中的任意元素。全局内存的读写可能会被缓存，这取决于设备能力。
* 常量内存（constant memory）：全局内存中的一块区域，在内核实例执行期间其保存的数据保持不变。对工作项而言这个内存对象是只读的，主机负责对该内存对象的分配和初始化。
* 局部内存（local memory）：这个内存区域对工作组是局部可见的，它可以用来分配由该工作组中所有工作项共享的变量。
* 私有内存（private memory）：这个内存区域是一个工作项的私有区域。一个工作项私有内存中定义的变量对其他工作项是不可见的。



主机内存在主机中

全局内存和常量内存由上下文中一个或多个设备共享，设备可能包含缓存对这两个内存高效访问

局部内存在计算单元中

私有内存在处理元素中

```mermaid
classDiagram

Host "1" *-- "1" HostMemory
HostMemory -- GlobalMemory
HostMemory -- ConstantMemory
GlobalMemory -- GlobalMemoryBuffer
ConstantMemory -- ConstantMemoryBuffer
Device "1" *-- "1" GlobalMemoryBuffer
Device "1" *-- "1" ConstantMemoryBuffer
Device "1" *-- "1..*" ComputeUnits
ComputeUnits "1" *-- "1..*" ProcessingUnits
ComputeUnits "1" *-- "1" LocalMemory
ProcessingUnits "1" *-- "1" PrivateMemory
```





#### 内存对象

内存对象表示全局内存区域中数据内容。



类型：

- 缓冲（buffer）：内核可用的一个连续的内存区域，编程人员可以将内建数据类型、矢量类型数据或用户自定义的数据结构（当然要符合OpenCL编程规范）映射到这个缓冲区，内核通过指针来访问缓冲区。
- 图像（image）：图像对象用于存储基于标准格式的图像。图像对象是一个不透明的数据结构，使用OpenCL API函数来管理。通常不允许OpenCL内核对单个图像同时进行读和写。然而在OpenCL 2.0中，提供了同步和栅栏操作来放宽这个限制。
- 管道（pipe）：管道内存是数据项有序的队列。管道有两个端点：一个是写端点，用于插入数据项；另一个是读端点，数据项从读端点被移除。同一时刻，仅有一个内核实例可向一个管道写入数据，同时仅有一个内核实例可从一个管道读出数据。



主机和设备的内存模型是独立的，内存模型的交互方式：

* 读/写/填充
  * 主机将读/写/填充的命令入队，数据在主机和全局内存之间传输。
* 映射和解映射
  * 将内存区域映射到主机可以访问的地址空间。
  * 在主机安全操作内存对象之前，主机需要将映射该内存对象的命令入队到命令队列。
  * 主机完成对内存对象操作后，主机需要将解映射的命令入队到命令队列，这样内存才能安全读写缓冲。
* 拷贝
  * 拷贝命令是将存储器对象在两个缓冲间拷贝，这两个缓冲可驻留在主机或设备上。

上述三个操作命令可以是阻塞或非阻塞操作。



#### 共享虚拟内存

通过映射，可以将全局内存区域映射到主机可以访问的地址空间。而除了这种方式，在OpenCL 2.0中，OpenCL通过共享虚拟内存（Shared Virtual Memory，SVM）机制扩展了全局内存区域到主机内存区域的方式。



OpenCL 2.0中定义了三种SVM类型：

- 粗粒度SVM：共享发生在OpenCL缓冲内存对象区域的粒度；
- 细粒度SVM：共享发生在OpenCL缓冲内存对象里独立地以字节加载/存储的粒度；
- 细粒度系统SVM：共享发生在主机内存内任何地方独立地以字节加载/存储的粒度。

粗粒度内存SVM是OpenCL的核心规范，而对于后两种细粒度实现是可选。



### 编程模型

The OpenCL Framework

框架让应用把主机和一到多个设备当做单个的异构并行计算机系统来使用，包含以下三个组件：

*  OpenCL平台层：这层允许host program来感知设备及设备能力和创建上下文
*  OpenCL Runtime：允许host program在创建上下文后控制它们
*  OpenCL compiler：创建包含OpenCL kernel的可执行程序。



## 基础教程

类图

![img](overview-of-opencl.assets/classDiagram.jpg)



流程

```mermaid
graph TD

查询平台 --> 查询设备
查询设备 --> 创建上下文
创建上下文 --> 创建命令队列
创建命令队列 --> 创建内存对象
创建内存对象 --> 创建程序对象
创建程序对象 --> 编译程序对象
编译程序对象 --> 创建内核对象
创建内核对象 --> 设置内存参数
设置内存参数 --> 执行内核
```

平台

设备

上下文

命令队列

内存对象

程序对象

内核对象

## OpenCL C

内核代码





## 同步及事件机制



